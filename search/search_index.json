{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Icecap Documentation","text":"<p>IceCap is a Python library for building World of Warcraft assistant applications. It provides a set of tools and utilities to interact with the game, automate tasks, and enhance the gaming experience.</p> <p>The library is built for WoW 3.3.5a (build 1340) and will not work with other versions of the game.</p>"},{"location":"#icecap","title":"IceCap","text":""},{"location":"#features","title":"Features","text":""},{"location":"#memory-management","title":"Memory management","text":"The library provides a memory management system that allows you to read and write to the game's memory. This enables you to access game data and manipulate it as needed."},{"location":"#entities-as-objects","title":"Entities as objects","text":"The library allows you to interact with game entities as Python objects, making it easier to work with them in your code."},{"location":"#client-assets-management","title":"Client assets management","text":"Access MPQ archives programmatically to load and use assets such as textures, maps, and models."},{"location":"#rpc","title":"RPC","text":"The library provides a simple asynchronous RPC system that allows you to call functions in the game's client process."},{"location":"getting_started/","title":"Getting Started with Icecap","text":"<p>This guide will help you get up and running with Icecap quickly.</p>"},{"location":"getting_started/#installation","title":"Installation","text":"<p>Install Icecap from PyPI using pip:</p> <pre><code>pip install icecap\n</code></pre>"},{"location":"getting_started/#basic-usage","title":"Basic Usage","text":"<p>Here's a minimal example to get you started with Icecap:</p> Finding players around you<pre><code>from icecap.infrastructure import (\n    get_memory_manager,\n    GameDriver,\n    PlayerRepository,\n)\nfrom icecap.infrastructure.process import get_game_process_manager\n\ndriver = GameDriver(get_game_process_manager(), get_memory_manager)\nplayer_repository = PlayerRepository(driver)\n\nfor player in player_repository.yield_players():\n    print(player)\n</code></pre> <p>Let's break down what's happening in this example:</p> <ol> <li>First, we create a <code>GameDriver</code> instance using the game process manager and memory manager getter.</li> <li>Next, we create a <code>PlayerRepository</code>, which provides access to player entities in the game.</li> <li>Finally, we iterate over all players in the game and print their details.</li> </ol>"},{"location":"getting_started/#next-steps","title":"Next Steps","text":"<p>Once you're familiar with the basics, check out the Tutorials for more detailed examples or explore the API Reference for complete documentation of all available components and their purpose.</p>"},{"location":"api/","title":"API Overview","text":"<p>This document provides an overview of the API structure for the project.</p>"},{"location":"api/#library-structure","title":"Library Structure","text":"<p>Icecap is organized into several layers:</p> <ul> <li> <p>Domain Layer: Contains the core business entities (models), data transfer objects (DTOs), and enumerations (enums) that represent the game's domain concepts.</p> </li> <li> <p>Infrastructure Layer: Provides the technical capabilities to interact with the game:</p> </li> <li> <p>Service Layer: Contains business logic.</p> </li> </ul> <p>This layered architecture separates the domain logic from the technical implementation, making the code more maintainable and extensible.</p>"},{"location":"api/services/","title":"Overview","text":""},{"location":"api/services/#icecap.services","title":"icecap.services","text":"<p>The module will contain services to interact with the game world.</p>"},{"location":"api/domain/dto/","title":"DTO","text":""},{"location":"api/domain/dto/#icecap.domain.dto","title":"icecap.domain.dto","text":"<p>Data transfer objects for the application.</p> <p>This module contains data structures used to transfer data between different parts of the application.</p> <p>Classes:</p> <ul> <li> <code>GameObjectFields</code>           \u2013            <p>Data class representing the fields of a game object.</p> </li> <li> <code>Position</code>           \u2013            <p>Data class representing a 3D position with rotation.</p> </li> <li> <code>UnitFields</code>           \u2013            <p>Data class representing the fields of a unit.</p> </li> </ul>"},{"location":"api/domain/dto/#icecap.domain.dto.GameObjectFields","title":"GameObjectFields  <code>dataclass</code>","text":"<pre><code>GameObjectFields(entry_id: int, display_id: int, owner_guid: int, state: int)\n</code></pre> <p>Data class representing the fields of a game object.</p> <p>Important note: The DTO does not contain all fields of the game object. For ah exhaustive list of available data, please refer to the C structs definitions in the infrastructure layer.</p> <p>Attributes:</p> <ul> <li> <code>display_id</code>               (<code>int</code>)           \u2013            <p>The display ID of the game object.</p> </li> <li> <code>entry_id</code>               (<code>int</code>)           \u2013            <p>The entry ID of the game object.</p> </li> <li> <code>owner_guid</code>               (<code>int</code>)           \u2013            <p>The GUID of the owner of the game object.</p> </li> <li> <code>state</code>               (<code>int</code>)           \u2013            <p>The state of the game object.</p> </li> </ul>"},{"location":"api/domain/dto/#icecap.domain.dto.GameObjectFields.display_id","title":"display_id  <code>instance-attribute</code>","text":"<pre><code>display_id: int\n</code></pre> <p>The display ID of the game object.</p> <p>It is used to determine the visual representation of the game object.</p>"},{"location":"api/domain/dto/#icecap.domain.dto.GameObjectFields.entry_id","title":"entry_id  <code>instance-attribute</code>","text":"<pre><code>entry_id: int\n</code></pre> <p>The entry ID of the game object.</p> <p>It indicates the game which template to use when placing the object in the world.</p>"},{"location":"api/domain/dto/#icecap.domain.dto.GameObjectFields.owner_guid","title":"owner_guid  <code>instance-attribute</code>","text":"<pre><code>owner_guid: int\n</code></pre> <p>The GUID of the owner of the game object.</p>"},{"location":"api/domain/dto/#icecap.domain.dto.GameObjectFields.state","title":"state  <code>instance-attribute</code>","text":"<pre><code>state: int\n</code></pre> <p>The state of the game object.</p> <p>For example, it can be used to check if a bobber is bobbing or not.</p>"},{"location":"api/domain/dto/#icecap.domain.dto.Position","title":"Position  <code>dataclass</code>","text":"<pre><code>Position(x: float, y: float, z: float, rotation: float)\n</code></pre> <p>Data class representing a 3D position with rotation.</p> <p>Attributes:</p> <ul> <li> <code>rotation</code>               (<code>float</code>)           \u2013            <p>The rotation angle in radians (0-2pi).</p> </li> <li> <code>x</code>               (<code>float</code>)           \u2013            <p>The x-coordinate of the position.</p> </li> <li> <code>y</code>               (<code>float</code>)           \u2013            <p>The y-coordinate of the position.</p> </li> <li> <code>z</code>               (<code>float</code>)           \u2013            <p>The z-coordinate of the position.</p> </li> </ul>"},{"location":"api/domain/dto/#icecap.domain.dto.Position.rotation","title":"rotation  <code>instance-attribute</code>","text":"<pre><code>rotation: float\n</code></pre> <p>The rotation angle in radians (0-2pi).</p>"},{"location":"api/domain/dto/#icecap.domain.dto.Position.x","title":"x  <code>instance-attribute</code>","text":"<pre><code>x: float\n</code></pre> <p>The x-coordinate of the position.</p>"},{"location":"api/domain/dto/#icecap.domain.dto.Position.y","title":"y  <code>instance-attribute</code>","text":"<pre><code>y: float\n</code></pre> <p>The y-coordinate of the position.</p>"},{"location":"api/domain/dto/#icecap.domain.dto.Position.z","title":"z  <code>instance-attribute</code>","text":"<pre><code>z: float\n</code></pre> <p>The z-coordinate of the position.</p>"},{"location":"api/domain/dto/#icecap.domain.dto.Position.get_distance_to","title":"get_distance_to","text":"<pre><code>get_distance_to(other: Position) -&gt; float\n</code></pre> <p>Calculates the distance to another position.</p> Source code in <code>icecap/domain/dto/position.py</code> <pre><code>def get_distance_to(self, other: \"Position\") -&gt; float:\n    \"\"\"Calculates the distance to another position.\"\"\"\n    return ((self.x - other.x) ** 2 + (self.y - other.y) ** 2 + (self.z - other.z) ** 2) ** 0.5\n</code></pre>"},{"location":"api/domain/dto/#icecap.domain.dto.UnitFields","title":"UnitFields  <code>dataclass</code>","text":"<pre><code>UnitFields(\n    level: int,\n    hit_points: int,\n    max_hit_points: int,\n    faction: Faction | None = None,\n    player_class: PlayerClass | None = None,\n    race: Race | None = None,\n    gender: Gender | None = None,\n    channel_spell: int | None = None,\n    channel_object: int | None = None,\n)\n</code></pre> <p>Data class representing the fields of a unit.</p> <p>This object is shared between players and units.</p> <p>Attributes:</p> <ul> <li> <code>channel_object</code>               (<code>int | None</code>)           \u2013            <p>The channel object of the unit, if applicable.</p> </li> <li> <code>channel_spell</code>               (<code>int | None</code>)           \u2013            <p>The channel spell of the unit, if applicable.</p> </li> <li> <code>faction</code>               (<code>Faction | None</code>)           \u2013            <p>The faction of the unit, if applicable.</p> </li> <li> <code>gender</code>               (<code>Gender | None</code>)           \u2013            <p>The gender of the unit, if applicable.</p> </li> <li> <code>hit_points</code>               (<code>int</code>)           \u2013            <p>The current hit points of the unit.</p> </li> <li> <code>level</code>               (<code>int</code>)           \u2013            <p>The level of the unit.</p> </li> <li> <code>max_hit_points</code>               (<code>int</code>)           \u2013            <p>The maximum hit points of the unit.</p> </li> <li> <code>player_class</code>               (<code>PlayerClass | None</code>)           \u2013            <p>The class of the player, if applicable.</p> </li> <li> <code>race</code>               (<code>Race | None</code>)           \u2013            <p>The race of the unit, if applicable.</p> </li> </ul>"},{"location":"api/domain/dto/#icecap.domain.dto.UnitFields.channel_object","title":"channel_object  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>channel_object: int | None = None\n</code></pre> <p>The channel object of the unit, if applicable.</p>"},{"location":"api/domain/dto/#icecap.domain.dto.UnitFields.channel_spell","title":"channel_spell  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>channel_spell: int | None = None\n</code></pre> <p>The channel spell of the unit, if applicable.</p>"},{"location":"api/domain/dto/#icecap.domain.dto.UnitFields.faction","title":"faction  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>faction: Faction | None = None\n</code></pre> <p>The faction of the unit, if applicable.</p>"},{"location":"api/domain/dto/#icecap.domain.dto.UnitFields.gender","title":"gender  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gender: Gender | None = None\n</code></pre> <p>The gender of the unit, if applicable.</p>"},{"location":"api/domain/dto/#icecap.domain.dto.UnitFields.hit_points","title":"hit_points  <code>instance-attribute</code>","text":"<pre><code>hit_points: int\n</code></pre> <p>The current hit points of the unit.</p>"},{"location":"api/domain/dto/#icecap.domain.dto.UnitFields.level","title":"level  <code>instance-attribute</code>","text":"<pre><code>level: int\n</code></pre> <p>The level of the unit.</p>"},{"location":"api/domain/dto/#icecap.domain.dto.UnitFields.max_hit_points","title":"max_hit_points  <code>instance-attribute</code>","text":"<pre><code>max_hit_points: int\n</code></pre> <p>The maximum hit points of the unit.</p>"},{"location":"api/domain/dto/#icecap.domain.dto.UnitFields.player_class","title":"player_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>player_class: PlayerClass | None = None\n</code></pre> <p>The class of the player, if applicable.</p>"},{"location":"api/domain/dto/#icecap.domain.dto.UnitFields.race","title":"race  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>race: Race | None = None\n</code></pre> <p>The race of the unit, if applicable.</p>"},{"location":"api/domain/enums/","title":"Enums","text":""},{"location":"api/domain/enums/#icecap.domain.enums","title":"icecap.domain.enums","text":"<p>Enumeration types for the IceCap domain.</p> <p>This module contains various enumeration types used throughout the application.</p> <p>Classes:</p> <ul> <li> <code>EntityType</code>           \u2013            <p>Enumeration of entity types in the game.</p> </li> <li> <code>Faction</code>           \u2013            <p>Enumeration of factions in the game.</p> </li> <li> <code>Gender</code>           \u2013            <p>Enumeration of genders in the game.</p> </li> <li> <code>PlayerClass</code>           \u2013            <p>Enumeration of player classes in the game.</p> </li> <li> <code>Race</code>           \u2013            <p>Enumeration of races in the game.</p> </li> </ul>"},{"location":"api/domain/enums/#icecap.domain.enums.EntityType","title":"EntityType","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of entity types in the game.</p>"},{"location":"api/domain/enums/#icecap.domain.enums.EntityType.CONTAINER","title":"CONTAINER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CONTAINER = 2\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.EntityType.CORPSE","title":"CORPSE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CORPSE = 7\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.EntityType.DYNAMIC_OBJECT","title":"DYNAMIC_OBJECT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DYNAMIC_OBJECT = 6\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.EntityType.GAME_OBJECT","title":"GAME_OBJECT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GAME_OBJECT = 5\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.EntityType.ITEM","title":"ITEM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ITEM = 1\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.EntityType.NONE","title":"NONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NONE = 0\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.EntityType.PLAYER","title":"PLAYER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PLAYER = 4\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.EntityType.UNIT","title":"UNIT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNIT = 3\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.Faction","title":"Faction","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of factions in the game.</p>"},{"location":"api/domain/enums/#icecap.domain.enums.Faction.ALLIANCE","title":"ALLIANCE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ALLIANCE = 0\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.Faction.HORDE","title":"HORDE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HORDE = 1\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.Faction.OTHER","title":"OTHER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OTHER = 2\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.Faction.from_race","title":"from_race  <code>classmethod</code>","text":"<pre><code>from_race(race: Race) -&gt; Faction\n</code></pre> <p>Returns the faction based on the race.</p> Source code in <code>icecap/domain/enums/faction.py</code> <pre><code>@classmethod\ndef from_race(cls, race: Race) -&gt; \"Faction\":\n    \"\"\"Returns the faction based on the race.\"\"\"\n    return cls.__race_to_faction__.get(race, cls.OTHER)  # type: ignore[return-value]\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.Gender","title":"Gender","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of genders in the game.</p>"},{"location":"api/domain/enums/#icecap.domain.enums.Gender.FEMALE","title":"FEMALE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FEMALE = 1\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.Gender.MALE","title":"MALE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MALE = 0\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.Gender.NEUTRAL","title":"NEUTRAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NEUTRAL = 2\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.PlayerClass","title":"PlayerClass","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of player classes in the game.</p>"},{"location":"api/domain/enums/#icecap.domain.enums.PlayerClass.DEATH_KNIGHT","title":"DEATH_KNIGHT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEATH_KNIGHT = 6\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.PlayerClass.DRUID","title":"DRUID  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DRUID = 11\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.PlayerClass.HUNTER","title":"HUNTER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HUNTER = 3\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.PlayerClass.MAGE","title":"MAGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAGE = 8\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.PlayerClass.PALADIN","title":"PALADIN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PALADIN = 2\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.PlayerClass.PRIEST","title":"PRIEST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PRIEST = 5\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.PlayerClass.ROGUE","title":"ROGUE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ROGUE = 4\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.PlayerClass.SHAMAN","title":"SHAMAN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SHAMAN = 7\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.PlayerClass.WARLOCK","title":"WARLOCK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WARLOCK = 9\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.PlayerClass.WARRIOR","title":"WARRIOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WARRIOR = 1\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.Race","title":"Race","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of races in the game.</p>"},{"location":"api/domain/enums/#icecap.domain.enums.Race.BLOOD_ELF","title":"BLOOD_ELF  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BLOOD_ELF = 10\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.Race.BROKEN","title":"BROKEN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BROKEN = 14\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.Race.DRAENEI","title":"DRAENEI  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DRAENEI = 11\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.Race.DWARF","title":"DWARF  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DWARF = 3\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.Race.FEL_ORC","title":"FEL_ORC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FEL_ORC = 12\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.Race.FOREST_TROLL","title":"FOREST_TROLL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FOREST_TROLL = 18\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.Race.GNOME","title":"GNOME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GNOME = 7\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.Race.GOBLIN","title":"GOBLIN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GOBLIN = 9\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.Race.HUMAN","title":"HUMAN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HUMAN = 1\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.Race.ICE_TROLL","title":"ICE_TROLL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ICE_TROLL = 21\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.Race.NAGA","title":"NAGA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NAGA = 13\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.Race.NEUTRAL","title":"NEUTRAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NEUTRAL = 0\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.Race.NIGHT_ELF","title":"NIGHT_ELF  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NIGHT_ELF = 4\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.Race.NORTREND_SKELETON","title":"NORTREND_SKELETON  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NORTREND_SKELETON = 20\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.Race.ORC","title":"ORC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ORC = 2\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.Race.SKELETON","title":"SKELETON  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SKELETON = 15\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.Race.TAUNKA","title":"TAUNKA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TAUNKA = 19\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.Race.TAUREN","title":"TAUREN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TAUREN = 6\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.Race.TROLL","title":"TROLL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TROLL = 8\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.Race.TUSKARR","title":"TUSKARR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TUSKARR = 17\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.Race.UNDEAD","title":"UNDEAD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNDEAD = 5\n</code></pre>"},{"location":"api/domain/enums/#icecap.domain.enums.Race.VRYKUL","title":"VRYKUL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VRYKUL = 16\n</code></pre>"},{"location":"api/domain/models/","title":"Models","text":""},{"location":"api/domain/models/#icecap.domain.models","title":"icecap.domain.models","text":"<p>This module contains models that represent various game entities. All models are read-only and represent the state of the game at a specific point in time.</p> <p>Important note: The models do not contain all fields of the game entities. For ah exhaustive list of available data, please refer to the C structs definitions in the infrastructure layer.</p> <p>Classes:</p> <ul> <li> <code>Entity</code>           \u2013            <p>Minimal lightweight representation of an object in the game.</p> </li> <li> <code>GameObject</code>           \u2013            <p>Representation of a game object.</p> </li> <li> <code>Player</code>           \u2013            <p>Representation of a player in the game.</p> </li> <li> <code>Unit</code>           \u2013            <p>Representation of a non-player unit in the game.</p> </li> </ul>"},{"location":"api/domain/models/#icecap.domain.models.Entity","title":"Entity  <code>dataclass</code>","text":"<pre><code>Entity(guid: int, object_address: int, entity_type: EntityType)\n</code></pre> <p>Minimal lightweight representation of an object in the game.</p> <p>This class serves as the base for all entity types and can be used for more detailed querying of the game state.</p> <p>Attributes:</p> <ul> <li> <code>entity_type</code>               (<code>EntityType</code>)           \u2013            <p>Entity type of the object.</p> </li> <li> <code>guid</code>               (<code>int</code>)           \u2013            <p>Global unique identifier of the entity.</p> </li> <li> <code>object_address</code>               (<code>int</code>)           \u2013            <p>Memory address of the object in the game.</p> </li> </ul>"},{"location":"api/domain/models/#icecap.domain.models.Entity.entity_type","title":"entity_type  <code>instance-attribute</code>","text":"<pre><code>entity_type: EntityType\n</code></pre> <p>Entity type of the object.</p> <p>This is used to differentiate between different types of entities in the game.</p>"},{"location":"api/domain/models/#icecap.domain.models.Entity.guid","title":"guid  <code>instance-attribute</code>","text":"<pre><code>guid: int\n</code></pre> <p>Global unique identifier of the entity.</p> <p>For players, this changes each time the player enters the world.</p>"},{"location":"api/domain/models/#icecap.domain.models.Entity.object_address","title":"object_address  <code>instance-attribute</code>","text":"<pre><code>object_address: int\n</code></pre> <p>Memory address of the object in the game.</p>"},{"location":"api/domain/models/#icecap.domain.models.GameObject","title":"GameObject  <code>dataclass</code>","text":"<pre><code>GameObject(\n    guid: int,\n    object_address: int,\n    entity_type: EntityType,\n    position: Position,\n    name: str,\n    game_object_fields: GameObjectFields,\n)\n</code></pre> <p>               Bases: <code>Entity</code></p> <p>Representation of a game object.</p> <p>Game objects are entities in the world that can be interacted with, manipulated, or observed.</p> <p>Attributes:</p> <ul> <li> <code>entity_type</code>               (<code>EntityType</code>)           \u2013            <p>Entity type of the object.</p> </li> <li> <code>game_object_fields</code>               (<code>GameObjectFields</code>)           \u2013            <p>Fields specific to the game object.</p> </li> <li> <code>guid</code>               (<code>int</code>)           \u2013            <p>Global unique identifier of the entity.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Human-readable name of the game object.</p> </li> <li> <code>object_address</code>               (<code>int</code>)           \u2013            <p>Memory address of the object in the game.</p> </li> <li> <code>position</code>               (<code>Position</code>)           \u2013            <p>The position of the game object in the world.</p> </li> </ul>"},{"location":"api/domain/models/#icecap.domain.models.GameObject.entity_type","title":"entity_type  <code>instance-attribute</code>","text":"<pre><code>entity_type: EntityType\n</code></pre> <p>Entity type of the object.</p> <p>This is used to differentiate between different types of entities in the game.</p>"},{"location":"api/domain/models/#icecap.domain.models.GameObject.game_object_fields","title":"game_object_fields  <code>instance-attribute</code>","text":"<pre><code>game_object_fields: GameObjectFields\n</code></pre> <p>Fields specific to the game object.</p>"},{"location":"api/domain/models/#icecap.domain.models.GameObject.guid","title":"guid  <code>instance-attribute</code>","text":"<pre><code>guid: int\n</code></pre> <p>Global unique identifier of the entity.</p> <p>For players, this changes each time the player enters the world.</p>"},{"location":"api/domain/models/#icecap.domain.models.GameObject.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Human-readable name of the game object.</p>"},{"location":"api/domain/models/#icecap.domain.models.GameObject.object_address","title":"object_address  <code>instance-attribute</code>","text":"<pre><code>object_address: int\n</code></pre> <p>Memory address of the object in the game.</p>"},{"location":"api/domain/models/#icecap.domain.models.GameObject.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: Position\n</code></pre> <p>The position of the game object in the world.</p>"},{"location":"api/domain/models/#icecap.domain.models.Player","title":"Player  <code>dataclass</code>","text":"<pre><code>Player(\n    guid: int,\n    object_address: int,\n    entity_type: EntityType,\n    position: Position,\n    name: str,\n    unit_fields: UnitFields,\n)\n</code></pre> <p>               Bases: <code>Entity</code></p> <p>Representation of a player in the game.</p> <p>Methods:</p> <ul> <li> <code>is_enemy</code>             \u2013              <p>Determines if the other player is an enemy.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>entity_type</code>               (<code>EntityType</code>)           \u2013            <p>Entity type of the object.</p> </li> <li> <code>guid</code>               (<code>int</code>)           \u2013            <p>Global unique identifier of the entity.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the player.</p> </li> <li> <code>object_address</code>               (<code>int</code>)           \u2013            <p>Memory address of the object in the game.</p> </li> <li> <code>position</code>               (<code>Position</code>)           \u2013            <p>The position of the player in the world.</p> </li> <li> <code>unit_fields</code>               (<code>UnitFields</code>)           \u2013            <p>Fields specific to the player.</p> </li> </ul>"},{"location":"api/domain/models/#icecap.domain.models.Player.entity_type","title":"entity_type  <code>instance-attribute</code>","text":"<pre><code>entity_type: EntityType\n</code></pre> <p>Entity type of the object.</p> <p>This is used to differentiate between different types of entities in the game.</p>"},{"location":"api/domain/models/#icecap.domain.models.Player.guid","title":"guid  <code>instance-attribute</code>","text":"<pre><code>guid: int\n</code></pre> <p>Global unique identifier of the entity.</p> <p>For players, this changes each time the player enters the world.</p>"},{"location":"api/domain/models/#icecap.domain.models.Player.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the player.</p>"},{"location":"api/domain/models/#icecap.domain.models.Player.object_address","title":"object_address  <code>instance-attribute</code>","text":"<pre><code>object_address: int\n</code></pre> <p>Memory address of the object in the game.</p>"},{"location":"api/domain/models/#icecap.domain.models.Player.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: Position\n</code></pre> <p>The position of the player in the world.</p>"},{"location":"api/domain/models/#icecap.domain.models.Player.unit_fields","title":"unit_fields  <code>instance-attribute</code>","text":"<pre><code>unit_fields: UnitFields\n</code></pre> <p>Fields specific to the player.</p>"},{"location":"api/domain/models/#icecap.domain.models.Player.is_enemy","title":"is_enemy","text":"<pre><code>is_enemy(other: Player) -&gt; bool\n</code></pre> <p>Determines if the other player is an enemy.</p> Source code in <code>icecap/domain/models/player.py</code> <pre><code>def is_enemy(self, other: \"Player\") -&gt; bool:\n    \"\"\"Determines if the other player is an enemy.\"\"\"\n    return self.unit_fields.faction != other.unit_fields.faction\n</code></pre>"},{"location":"api/domain/models/#icecap.domain.models.Unit","title":"Unit  <code>dataclass</code>","text":"<pre><code>Unit(\n    guid: int,\n    object_address: int,\n    entity_type: EntityType,\n    position: Position,\n    name: str,\n    unit_fields: UnitFields,\n)\n</code></pre> <p>               Bases: <code>Entity</code></p> <p>Representation of a non-player unit in the game.</p> <p>Attributes:</p> <ul> <li> <code>entity_type</code>               (<code>EntityType</code>)           \u2013            <p>Entity type of the object.</p> </li> <li> <code>guid</code>               (<code>int</code>)           \u2013            <p>Global unique identifier of the entity.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the unit, typically a creature or NPC.</p> </li> <li> <code>object_address</code>               (<code>int</code>)           \u2013            <p>Memory address of the object in the game.</p> </li> <li> <code>position</code>               (<code>Position</code>)           \u2013            <p>The position of the unit in the world.</p> </li> <li> <code>unit_fields</code>               (<code>UnitFields</code>)           \u2013            <p>Fields specific to the unit.</p> </li> </ul>"},{"location":"api/domain/models/#icecap.domain.models.Unit.entity_type","title":"entity_type  <code>instance-attribute</code>","text":"<pre><code>entity_type: EntityType\n</code></pre> <p>Entity type of the object.</p> <p>This is used to differentiate between different types of entities in the game.</p>"},{"location":"api/domain/models/#icecap.domain.models.Unit.guid","title":"guid  <code>instance-attribute</code>","text":"<pre><code>guid: int\n</code></pre> <p>Global unique identifier of the entity.</p> <p>For players, this changes each time the player enters the world.</p>"},{"location":"api/domain/models/#icecap.domain.models.Unit.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the unit, typically a creature or NPC.</p>"},{"location":"api/domain/models/#icecap.domain.models.Unit.object_address","title":"object_address  <code>instance-attribute</code>","text":"<pre><code>object_address: int\n</code></pre> <p>Memory address of the object in the game.</p>"},{"location":"api/domain/models/#icecap.domain.models.Unit.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: Position\n</code></pre> <p>The position of the unit in the world.</p>"},{"location":"api/domain/models/#icecap.domain.models.Unit.unit_fields","title":"unit_fields  <code>instance-attribute</code>","text":"<pre><code>unit_fields: UnitFields\n</code></pre> <p>Fields specific to the unit.</p>"},{"location":"api/infrastructure/communication/","title":"Communication","text":""},{"location":"api/infrastructure/communication/#icecap.infrastructure.communication.rpc","title":"icecap.infrastructure.communication.rpc","text":"<p>Classes:</p> <ul> <li> <code>AgentClient</code>           \u2013            <p>High-level client for communicating with icecap-agent.</p> </li> <li> <code>AgentClientEventHandler</code>           \u2013            <p>Callback protocol for handling agent events.</p> </li> <li> <code>AgentConnectionError</code>           \u2013            <p>Raised when connection to an agent fails or is lost.</p> </li> <li> <code>AgentError</code>           \u2013            <p>Base exception for agent client errors.</p> </li> <li> <code>AgentTimeoutError</code>           \u2013            <p>Raised when waiting for a response times out.</p> </li> </ul>"},{"location":"api/infrastructure/communication/#icecap.infrastructure.communication.rpc.AgentClient","title":"AgentClient","text":"<p>               Bases: <code>Protocol</code></p> <p>High-level client for communicating with icecap-agent.</p>"},{"location":"api/infrastructure/communication/#icecap.infrastructure.communication.rpc.AgentClient.add_event_handler","title":"add_event_handler","text":"<pre><code>add_event_handler(callback: AgentClientEventHandler) -&gt; None\n</code></pre> <p>Add an event handler for all received events.</p> <p>Parameters:</p> Source code in <code>icecap/infrastructure/communication/rpc/interface.py</code> <pre><code>def add_event_handler(self, callback: AgentClientEventHandler) -&gt; None:\n    \"\"\"Add an event handler for all received events.\n\n    Args:\n        callback: Function to call for each event\n    \"\"\"\n</code></pre>"},{"location":"api/infrastructure/communication/#icecap.infrastructure.communication.rpc.AgentClient.add_event_handler(callback)","title":"<code>callback</code>","text":"(<code>AgentClientEventHandler</code>)           \u2013            <p>Function to call for each event</p>"},{"location":"api/infrastructure/communication/#icecap.infrastructure.communication.rpc.AgentClient.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the connection to the agent.</p> Source code in <code>icecap/infrastructure/communication/rpc/interface.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the connection to the agent.\"\"\"\n</code></pre>"},{"location":"api/infrastructure/communication/#icecap.infrastructure.communication.rpc.AgentClient.connect","title":"connect","text":"<pre><code>connect(timeout: float = 5.0) -&gt; None\n</code></pre> <p>Connect to the agent.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>AgentConnectionError</code>             \u2013            <p>If connection fails</p> </li> </ul> Source code in <code>icecap/infrastructure/communication/rpc/interface.py</code> <pre><code>def connect(self, timeout: float = 5.0) -&gt; None:\n    \"\"\"Connect to the agent.\n\n    Args:\n        timeout: Connection timeout in seconds\n\n    Raises:\n        AgentConnectionError: If connection fails\n    \"\"\"\n</code></pre>"},{"location":"api/infrastructure/communication/#icecap.infrastructure.communication.rpc.AgentClient.connect(timeout)","title":"<code>timeout</code>","text":"(<code>float</code>, default:                   <code>5.0</code> )           \u2013            <p>Connection timeout in seconds</p>"},{"location":"api/infrastructure/communication/#icecap.infrastructure.communication.rpc.AgentClient.is_connected","title":"is_connected","text":"<pre><code>is_connected() -&gt; bool\n</code></pre> <p>Check if the client is connected to the agent.</p> Source code in <code>icecap/infrastructure/communication/rpc/interface.py</code> <pre><code>def is_connected(self) -&gt; bool:\n    \"\"\"Check if the client is connected to the agent.\"\"\"\n</code></pre>"},{"location":"api/infrastructure/communication/#icecap.infrastructure.communication.rpc.AgentClient.remove_event_handler","title":"remove_event_handler","text":"<pre><code>remove_event_handler(callback: AgentClientEventHandler) -&gt; None\n</code></pre> <p>Remove an event handler.</p> <p>Parameters:</p> Source code in <code>icecap/infrastructure/communication/rpc/interface.py</code> <pre><code>def remove_event_handler(self, callback: AgentClientEventHandler) -&gt; None:\n    \"\"\"Remove an event handler.\n\n    Args:\n        callback: Handler to remove\n    \"\"\"\n</code></pre>"},{"location":"api/infrastructure/communication/#icecap.infrastructure.communication.rpc.AgentClient.remove_event_handler(callback)","title":"<code>callback</code>","text":"(<code>AgentClientEventHandler</code>)           \u2013            <p>Handler to remove</p>"},{"location":"api/infrastructure/communication/#icecap.infrastructure.communication.rpc.AgentClient.send","title":"send","text":"<pre><code>send(command: Command, timeout: float = 5.0) -&gt; Event\n</code></pre> <p>Send a command and wait for the response event.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>The response event with matching operation_id</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AgentConnectionError</code>             \u2013            <p>If not connected or connection fails</p> </li> <li> <code>AgentTimeoutError</code>             \u2013            <p>If no response is received within timeout</p> </li> </ul> Source code in <code>icecap/infrastructure/communication/rpc/interface.py</code> <pre><code>def send(self, command: commands_pb2.Command, timeout: float = 5.0) -&gt; events_pb2.Event:\n    \"\"\"Send a command and wait for the response event.\n\n    Args:\n        command: Command protobuf to send\n        timeout: Maximum time to wait for response in seconds (None = wait forever)\n\n    Returns:\n        The response event with matching operation_id\n\n    Raises:\n        AgentConnectionError: If not connected or connection fails\n        AgentTimeoutError: If no response is received within timeout\n    \"\"\"\n</code></pre>"},{"location":"api/infrastructure/communication/#icecap.infrastructure.communication.rpc.AgentClient.send(command)","title":"<code>command</code>","text":"(<code>Command</code>)           \u2013            <p>Command protobuf to send</p>"},{"location":"api/infrastructure/communication/#icecap.infrastructure.communication.rpc.AgentClient.send(timeout)","title":"<code>timeout</code>","text":"(<code>float</code>, default:                   <code>5.0</code> )           \u2013            <p>Maximum time to wait for response in seconds (None = wait forever)</p>"},{"location":"api/infrastructure/communication/#icecap.infrastructure.communication.rpc.AgentClientEventHandler","title":"AgentClientEventHandler","text":"<p>               Bases: <code>Protocol</code></p> <p>Callback protocol for handling agent events.</p> <p>Can be either class-based or function-based.</p>"},{"location":"api/infrastructure/communication/#icecap.infrastructure.communication.rpc.AgentClientEventHandler.__call__","title":"__call__","text":"<pre><code>__call__(event: Event) -&gt; None\n</code></pre> <p>Handle an agent event.</p> <p>Parameters:</p> Source code in <code>icecap/infrastructure/communication/rpc/interface.py</code> <pre><code>def __call__(self, event: events_pb2.Event) -&gt; None:\n    \"\"\"Handle an agent event.\n\n    Args:\n        event: The event received from the agent\n    \"\"\"\n</code></pre>"},{"location":"api/infrastructure/communication/#icecap.infrastructure.communication.rpc.AgentClientEventHandler.__call__(event)","title":"<code>event</code>","text":"(<code>Event</code>)           \u2013            <p>The event received from the agent</p>"},{"location":"api/infrastructure/communication/#icecap.infrastructure.communication.rpc.AgentConnectionError","title":"AgentConnectionError","text":"<p>               Bases: <code>AgentError</code></p> <p>Raised when connection to an agent fails or is lost.</p>"},{"location":"api/infrastructure/communication/#icecap.infrastructure.communication.rpc.AgentError","title":"AgentError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for agent client errors.</p>"},{"location":"api/infrastructure/communication/#icecap.infrastructure.communication.rpc.AgentTimeoutError","title":"AgentTimeoutError","text":"<p>               Bases: <code>AgentError</code></p> <p>Raised when waiting for a response times out.</p>"},{"location":"api/infrastructure/driver/","title":"Driver","text":"<p>Driver is one of the core modules of the library. </p> <p>The main purpose of the module is to encapsulate the low-level interactions with the game client's memory and provide an  interface for accessing and manipulating game data.</p> <p>Key responsibilities include:</p> <ul> <li>Memory access and manipulation</li> <li>Game entity management</li> <li>Process interaction handling</li> </ul>"},{"location":"api/infrastructure/driver/#important-implementation-details","title":"Important implementation details","text":"<p>The <code>GameDriver</code> class automatically handles the following scenarios:</p> <ul> <li>Game client recreation</li> <li>Local player change</li> <li>Logging out &amp; Logging in</li> </ul> <p>The driver detects any of these events and automatically reinitiates affected dependencies.</p>"},{"location":"api/infrastructure/driver/#icecap.infrastructure.driver","title":"icecap.infrastructure.driver","text":"<p>The module provides low-level tooling for interacting with the game client.</p> <p>Classes:</p> <ul> <li> <code>GameDriver</code>           \u2013            <p>Provides an interface to interact with the game's memory and objects.</p> </li> <li> <code>ObjectManager</code>           \u2013            <p>Represents the Object Manager in the game client.</p> </li> </ul>"},{"location":"api/infrastructure/driver/#icecap.infrastructure.driver.GameDriver","title":"GameDriver","text":"<pre><code>GameDriver(\n    game_process_manager: GameProcessManager, memory_manager_getter: MemoryManagerGetter\n)\n</code></pre> <p>Provides an interface to interact with the game's memory and objects.</p> <p>It serves as the main entry point for low-level accessing game data and functionality.</p> Source code in <code>icecap/infrastructure/driver/driver.py</code> <pre><code>def __init__(\n    self, game_process_manager: GameProcessManager, memory_manager_getter: MemoryManagerGetter\n):\n    self.game_process_manager = game_process_manager\n    self.memory_manager_getter = memory_manager_getter\n\n    self._name_resolver: NameResolver | None = None\n    self._memory_manager: MemoryManager | None = None\n    self._object_manager: ObjectManager | None = None\n    self._last_known_object_manager_address: int | None = None\n</code></pre>"},{"location":"api/infrastructure/driver/#icecap.infrastructure.driver.GameDriver.game_process_manager","title":"game_process_manager  <code>instance-attribute</code>","text":"<pre><code>game_process_manager: GameProcessManager = game_process_manager\n</code></pre> <p>Game process manager for interacting with the game process.</p>"},{"location":"api/infrastructure/driver/#icecap.infrastructure.driver.GameDriver.memory_manager","title":"memory_manager  <code>property</code>","text":"<pre><code>memory_manager: MemoryManager\n</code></pre> <p>A memory manager instance for accessing the game's memory.</p> <p>The attribute may return different objects depending on the state of the driver.</p>"},{"location":"api/infrastructure/driver/#icecap.infrastructure.driver.GameDriver.memory_manager_getter","title":"memory_manager_getter  <code>instance-attribute</code>","text":"<pre><code>memory_manager_getter: MemoryManagerGetter = memory_manager_getter\n</code></pre> <p>Callable that returns a MemoryManager instance for the game process.</p> <p>This is used to access the game's memory and objects. Can't use static memory_manager because game process may change.</p>"},{"location":"api/infrastructure/driver/#icecap.infrastructure.driver.GameDriver.name_resolver","title":"name_resolver  <code>property</code>","text":"<pre><code>name_resolver: NameResolver\n</code></pre> <p>A name resolver instance for resolving names of game entities.</p> <p>The attribute may return different objects depending on the state of the driver.</p>"},{"location":"api/infrastructure/driver/#icecap.infrastructure.driver.GameDriver.object_manager","title":"object_manager  <code>property</code>","text":"<pre><code>object_manager: ObjectManager\n</code></pre> <p>The object manager instance for accessing the game's objects.</p> <p>The attribute may return different objects depending on the state of the driver.</p>"},{"location":"api/infrastructure/driver/#icecap.infrastructure.driver.GameDriver.get_client_connection_address","title":"get_client_connection_address","text":"<pre><code>get_client_connection_address() -&gt; int\n</code></pre> <p>This method reads the client connection address from memory using a static offset.</p> Source code in <code>icecap/infrastructure/driver/driver.py</code> <pre><code>def get_client_connection_address(self) -&gt; int:\n    \"\"\"This method reads the client connection address from memory using a static offset.\"\"\"\n    address = self.memory_manager.read_uint(CLIENT_CONNECTION_OFFSET)\n    return address\n</code></pre>"},{"location":"api/infrastructure/driver/#icecap.infrastructure.driver.GameDriver.get_local_player_guid","title":"get_local_player_guid","text":"<pre><code>get_local_player_guid() -&gt; int\n</code></pre> <p>Retrieve the GUID of the local player using a static offset.</p> <p>Uses static offset which is less reliable than dynamic address, but it is faster and does not require reading the object manager.</p> <p>This is useful for quick checks or when the object manager is not available. For example, this can be used to check if the player is in the game world.</p> Source code in <code>icecap/infrastructure/driver/driver.py</code> <pre><code>def get_local_player_guid(self) -&gt; int:\n    \"\"\"Retrieve the GUID of the local player using a static offset.\n\n    Uses static offset which is less reliable than dynamic address,\n    but it is faster and does not require reading the object manager.\n\n    This is useful for quick checks or when the object manager is not available.\n    For example, this can be used to check if the player is in the game world.\n    \"\"\"\n    return self.memory_manager.read_ulonglong(LOCAL_PLAYER_GUID_STATIC_OFFSET)\n</code></pre>"},{"location":"api/infrastructure/driver/#icecap.infrastructure.driver.GameDriver.is_game_running","title":"is_game_running","text":"<pre><code>is_game_running() -&gt; bool\n</code></pre> <p>Check if the game is running.</p> Source code in <code>icecap/infrastructure/driver/driver.py</code> <pre><code>def is_game_running(self) -&gt; bool:\n    \"\"\"Check if the game is running.\"\"\"\n\n    return bool(self.game_process_manager.get_process_id())\n</code></pre>"},{"location":"api/infrastructure/driver/#icecap.infrastructure.driver.GameDriver.is_player_in_game","title":"is_player_in_game","text":"<pre><code>is_player_in_game() -&gt; bool\n</code></pre> <p>Check if the player is in the game world.</p> <p>This method uses the local player GUID to determine if the player is in the game. The GUID is non-zero only when the player is in the game.</p> Source code in <code>icecap/infrastructure/driver/driver.py</code> <pre><code>def is_player_in_game(self) -&gt; bool:\n    \"\"\"Check if the player is in the game world.\n\n    This method uses the local player GUID to determine if the player is in the game.\n    The GUID is non-zero only when the player is in the game.\n    \"\"\"\n    return self.get_local_player_guid() != 0\n</code></pre>"},{"location":"api/infrastructure/driver/#icecap.infrastructure.driver.ObjectManager","title":"ObjectManager","text":"<pre><code>ObjectManager(memory_manager: MemoryManager, address: int, max_objects: int = 1000)\n</code></pre> <p>Represents the Object Manager in the game client.</p> <p>The Object Manager is responsible for keeping track of all game objects, units, and players in the game world. This class provides methods to access and interact with these entities through memory reading operations.</p> Source code in <code>icecap/infrastructure/driver/object_manager.py</code> <pre><code>def __init__(\n    self,\n    memory_manager: MemoryManager,\n    address: int,\n    max_objects: int = 1000,\n):\n    self.memory_manager = memory_manager\n    self.address = address\n    self.max_objects = max_objects\n</code></pre>"},{"location":"api/infrastructure/driver/#icecap.infrastructure.driver.ObjectManager.get_entity_position","title":"get_entity_position","text":"<pre><code>get_entity_position(entity: Entity) -&gt; ObjectPosition\n</code></pre> <p>Retrieve the position of an entity in the game world.</p> <p>This method reads the entity's position data from memory and returns it as an ObjectPosition object containing x, y, z coordinates and rotation.</p> Source code in <code>icecap/infrastructure/driver/object_manager.py</code> <pre><code>def get_entity_position(self, entity: Entity) -&gt; ObjectPosition:\n    \"\"\"Retrieve the position of an entity in the game world.\n\n    This method reads the entity's position data from memory and returns it\n    as an ObjectPosition object containing x, y, z coordinates and rotation.\n    \"\"\"\n    position_offset = (\n        GAME_OBJECT_X_POSITION_OFFSET\n        if entity.entity_type == EntityType.GAME_OBJECT\n        else UNIT_X_POSITION_OFFSET\n    )\n\n    object_position = self.memory_manager.read_ctype_dataclass(\n        entity.object_address + position_offset, ObjectPosition\n    )\n\n    return object_position\n</code></pre>"},{"location":"api/infrastructure/driver/#icecap.infrastructure.driver.ObjectManager.get_game_object_fields","title":"get_game_object_fields","text":"<pre><code>get_game_object_fields(entity: Entity) -&gt; GameObjectFields\n</code></pre> <p>Retrieve the game object fields of a game object entity.</p> <p>This method reads the game object's field data from memory and returns it as a GameObjectFields object that corresponds to the C struct definition.</p> Source code in <code>icecap/infrastructure/driver/object_manager.py</code> <pre><code>def get_game_object_fields(self, entity: Entity) -&gt; GameObjectFields:\n    \"\"\"Retrieve the game object fields of a game object entity.\n\n    This method reads the game object's field data from memory and returns it as a\n    GameObjectFields object that corresponds to the C struct definition.\n    \"\"\"\n    fields_address = self.memory_manager.read_uint(entity.object_address + OBJECT_FIELDS_OFFSET)\n\n    game_object_fields = self.memory_manager.read_ctype_dataclass(\n        fields_address, GameObjectFields\n    )\n\n    return game_object_fields\n</code></pre>"},{"location":"api/infrastructure/driver/#icecap.infrastructure.driver.ObjectManager.get_local_player_guid","title":"get_local_player_guid","text":"<pre><code>get_local_player_guid() -&gt; int\n</code></pre> <p>Retrieve the GUID of the local player using a dynamic address.</p> <p>This method uses a dynamic address that should be more reliable than static offsets. It reads the local player GUID directly from the object manager.</p> Source code in <code>icecap/infrastructure/driver/object_manager.py</code> <pre><code>def get_local_player_guid(self) -&gt; int:\n    \"\"\"Retrieve the GUID of the local player using a dynamic address.\n\n    This method uses a dynamic address that should be more reliable than static offsets.\n    It reads the local player GUID directly from the object manager.\n    \"\"\"\n    return self.memory_manager.read_ulonglong(self.address + LOCAL_PLAYER_GUID_OFFSET)\n</code></pre>"},{"location":"api/infrastructure/driver/#icecap.infrastructure.driver.ObjectManager.get_map_id","title":"get_map_id","text":"<pre><code>get_map_id() -&gt; int\n</code></pre> <p>Retrieve the map ID from the object manager.</p> <p>It can be used to identify the current map and get extra information from the map database.</p> Source code in <code>icecap/infrastructure/driver/object_manager.py</code> <pre><code>def get_map_id(self) -&gt; int:\n    \"\"\"Retrieve the map ID from the object manager.\n\n    It can be used to identify the current map and get extra information\n    from the map database.\n    \"\"\"\n\n    return self.memory_manager.read_uint(self.address + MAP_ID_OFFSET)\n</code></pre>"},{"location":"api/infrastructure/driver/#icecap.infrastructure.driver.ObjectManager.get_unit_fields","title":"get_unit_fields","text":"<pre><code>get_unit_fields(entity: Entity) -&gt; UnitFields\n</code></pre> <p>Retrieve the unit fields of an entity.</p> <p>This method reads the unit's field data from memory and returns it as a UnitFields object that corresponds to the C struct definition.</p> Source code in <code>icecap/infrastructure/driver/object_manager.py</code> <pre><code>def get_unit_fields(self, entity: Entity) -&gt; UnitFields:\n    \"\"\"Retrieve the unit fields of an entity.\n\n    This method reads the unit's field data from memory and returns it as a\n    UnitFields object that corresponds to the C struct definition.\n    \"\"\"\n    unit_fields_address = self.memory_manager.read_uint(\n        entity.object_address + OBJECT_FIELDS_OFFSET\n    )\n\n    unit_fields = self.memory_manager.read_ctype_dataclass(unit_fields_address, UnitFields)\n\n    return unit_fields\n</code></pre>"},{"location":"api/infrastructure/driver/#icecap.infrastructure.driver.ObjectManager.yield_objects","title":"yield_objects","text":"<pre><code>yield_objects() -&gt; Generator[Entity, None, None]\n</code></pre> <p>Yield all objects in the Object Manager.</p> <p>This method iterates through the linked list of objects in the Object Manager and yields each one as an Entity object.</p> Source code in <code>icecap/infrastructure/driver/object_manager.py</code> <pre><code>def yield_objects(self) -&gt; Generator[Entity, None, None]:\n    \"\"\"Yield all objects in the Object Manager.\n\n    This method iterates through the linked list of objects in the Object Manager\n    and yields each one as an Entity object.\n    \"\"\"\n    checked_objects = 0\n    current_object_address = self.memory_manager.read_uint(self.address + FIRST_OBJECT_OFFSET)\n\n    while checked_objects &lt; self.max_objects:\n        try:\n            object_type = EntityType(\n                self.memory_manager.read_uint(current_object_address + OBJECT_TYPE_OFFSET)\n            )\n        except Exception:\n            break\n\n        object_guid = self.memory_manager.read_ulonglong(\n            current_object_address + OBJECT_GUID_OFFSET\n        )\n\n        yield Entity(\n            guid=object_guid,\n            object_address=current_object_address,\n            entity_type=object_type,\n        )\n\n        checked_objects += 1\n        current_object_address = self.memory_manager.read_uint(\n            current_object_address + NEXT_OBJECT_OFFSET\n        )\n</code></pre>"},{"location":"api/infrastructure/memory_manager/","title":"Memory Manager","text":""},{"location":"api/infrastructure/memory_manager/#icecap.infrastructure.memory_manager","title":"icecap.infrastructure.memory_manager","text":""},{"location":"api/infrastructure/memory_manager/#icecap.infrastructure.memory_manager.MemoryManager","title":"MemoryManager","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/infrastructure/memory_manager/#icecap.infrastructure.memory_manager.MemoryManager.read_bytes","title":"read_bytes","text":"<pre><code>read_bytes(address: int, size: int) -&gt; bytes\n</code></pre> <p>Read a sequence of bytes from the given address.</p> Source code in <code>icecap/infrastructure/memory_manager/interface.py</code> <pre><code>def read_bytes(self, address: int, size: int) -&gt; bytes:\n    \"\"\"Read a sequence of bytes from the given address.\"\"\"\n</code></pre>"},{"location":"api/infrastructure/memory_manager/#icecap.infrastructure.memory_manager.MemoryManager.read_ctype_dataclass","title":"read_ctype_dataclass","text":"<pre><code>read_ctype_dataclass(address: int, dataclass: Type[CStructTypeVar]) -&gt; CStructTypeVar\n</code></pre> <p>Read a C-typed structure dataclass from the given address.</p> Source code in <code>icecap/infrastructure/memory_manager/interface.py</code> <pre><code>def read_ctype_dataclass(self, address: int, dataclass: Type[CStructTypeVar]) -&gt; CStructTypeVar:\n    \"\"\"Read a C-typed structure dataclass from the given address.\"\"\"\n</code></pre>"},{"location":"api/infrastructure/memory_manager/#icecap.infrastructure.memory_manager.MemoryManager.read_float","title":"read_float","text":"<pre><code>read_float(address: int) -&gt; float\n</code></pre> <p>Read a 4 bytes float from the given address.</p> Source code in <code>icecap/infrastructure/memory_manager/interface.py</code> <pre><code>def read_float(self, address: int) -&gt; float:\n    \"\"\"Read a 4 bytes float from the given address.\"\"\"\n</code></pre>"},{"location":"api/infrastructure/memory_manager/#icecap.infrastructure.memory_manager.MemoryManager.read_short","title":"read_short","text":"<pre><code>read_short(address: int) -&gt; int\n</code></pre> <p>Read a signed 2 bytes integer from the given address.</p> Source code in <code>icecap/infrastructure/memory_manager/interface.py</code> <pre><code>def read_short(self, address: int) -&gt; int:\n    \"\"\"Read a signed 2 bytes integer from the given address.\"\"\"\n</code></pre>"},{"location":"api/infrastructure/memory_manager/#icecap.infrastructure.memory_manager.MemoryManager.read_string","title":"read_string","text":"<pre><code>read_string(address: int, length: int) -&gt; str\n</code></pre> <p>Read a string from the given address with the specified length.</p> Source code in <code>icecap/infrastructure/memory_manager/interface.py</code> <pre><code>def read_string(self, address: int, length: int) -&gt; str:\n    \"\"\"Read a string from the given address with the specified length.\"\"\"\n</code></pre>"},{"location":"api/infrastructure/memory_manager/#icecap.infrastructure.memory_manager.MemoryManager.read_uint","title":"read_uint","text":"<pre><code>read_uint(address: int) -&gt; int\n</code></pre> <p>Read an unsigned 4 bytes integer from the given address.</p> Source code in <code>icecap/infrastructure/memory_manager/interface.py</code> <pre><code>def read_uint(self, address: int) -&gt; int:\n    \"\"\"Read an unsigned 4 bytes integer from the given address.\"\"\"\n</code></pre>"},{"location":"api/infrastructure/memory_manager/#icecap.infrastructure.memory_manager.MemoryManager.read_ulonglong","title":"read_ulonglong","text":"<pre><code>read_ulonglong(address: int) -&gt; int\n</code></pre> <p>Read an unsigned 8 bytes integer from the given address.</p> Source code in <code>icecap/infrastructure/memory_manager/interface.py</code> <pre><code>def read_ulonglong(self, address: int) -&gt; int:\n    \"\"\"Read an unsigned 8 bytes integer from the given address.\"\"\"\n</code></pre>"},{"location":"api/infrastructure/memory_manager/#icecap.infrastructure.memory_manager.MemoryManager.write_ulonglong","title":"write_ulonglong","text":"<pre><code>write_ulonglong(address: int, value: int) -&gt; None\n</code></pre> <p>Write an unsigned 8-byte integer to the given address.</p> Source code in <code>icecap/infrastructure/memory_manager/interface.py</code> <pre><code>def write_ulonglong(self, address: int, value: int) -&gt; None:\n    \"\"\"Write an unsigned 8-byte integer to the given address.\"\"\"\n</code></pre>"},{"location":"api/infrastructure/memory_manager/#icecap.infrastructure.memory_manager.get_memory_manager","title":"get_memory_manager","text":"<pre><code>get_memory_manager(pid: int) -&gt; MemoryManager\n</code></pre> <p>Factory function to get the appropriate memory manager based on the OS.</p> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>If the current OS is not supported</p> </li> </ul> Source code in <code>icecap/infrastructure/memory_manager/factory.py</code> <pre><code>def get_memory_manager(pid: int) -&gt; MemoryManager:\n    \"\"\"Factory function to get the appropriate memory manager based on the OS.\n\n    Raises:\n        NotImplementedError: If the current OS is not supported\n    \"\"\"\n    if OS_SYSTEM == \"Linux\":\n        return LinuxMemoryManager(pid)\n    elif OS_SYSTEM == \"Windows\":\n        return WindowsMemoryManager(pid)\n\n    raise NotImplementedError(f\"Memory manager for {OS_SYSTEM} is not implemented.\")\n</code></pre>"},{"location":"api/infrastructure/name_resolver/","title":"Name Resolver","text":""},{"location":"api/infrastructure/name_resolver/#icecap.infrastructure.name_resolver","title":"icecap.infrastructure.name_resolver","text":"<p>The name resolver module.</p> <p>Classes:</p> <ul> <li> <code>NameResolver</code>           \u2013            <p>Resolves names for game entities within the game.</p> </li> </ul>"},{"location":"api/infrastructure/name_resolver/#icecap.infrastructure.name_resolver.NameResolver","title":"NameResolver","text":"<p>               Bases: <code>Protocol</code></p> <p>Resolves names for game entities within the game.</p> <p>This class provides methods to resolve names for different types of game entities such as units, players, and game objects.</p>"},{"location":"api/infrastructure/name_resolver/#icecap.infrastructure.name_resolver.NameResolver.resolve_game_object_name_by_display_id","title":"resolve_game_object_name_by_display_id","text":"<pre><code>resolve_game_object_name_by_display_id(display_id: int) -&gt; str\n</code></pre> <p>Resolve the name of a game object by its display ID.</p> <p>Note that there is no uniqueness guarantee, as multiple game objects can share the same display ID. The method returns the first matching name found.</p>"},{"location":"api/infrastructure/name_resolver/#icecap.infrastructure.name_resolver.NameResolver.resolve_game_object_name_by_entry_id","title":"resolve_game_object_name_by_entry_id","text":"<pre><code>resolve_game_object_name_by_entry_id(entry_id: int) -&gt; str\n</code></pre> <p>Resolve the name of a game object by its entry ID.</p>"},{"location":"api/infrastructure/name_resolver/#icecap.infrastructure.name_resolver.NameResolver.resolve_name","title":"resolve_name","text":"<pre><code>resolve_name(entity: Entity) -&gt; str\n</code></pre> <p>Resolve the name of an entity based on its type.</p> <p>For game objects, use resolve_game_object_name_by_entry_id instead.</p>"},{"location":"api/infrastructure/name_resolver/#icecap.infrastructure.name_resolver.get_name_resolver","title":"get_name_resolver","text":"<pre><code>get_name_resolver(\n    memory_manager: MemoryManager, data_mapping_filename: str | None = None\n) -&gt; NameResolver\n</code></pre> <p>Create and return a NameResolver instance.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>NameResolver</code>           \u2013            <p>A NameResolver instance.</p> </li> </ul>"},{"location":"api/infrastructure/name_resolver/#icecap.infrastructure.name_resolver.get_name_resolver(memory_manager)","title":"<code>memory_manager</code>","text":"(<code>MemoryManager</code>)           \u2013            <p>The memory manager to use for reading memory.</p>"},{"location":"api/infrastructure/name_resolver/#icecap.infrastructure.name_resolver.get_name_resolver(data_mapping_filename)","title":"<code>data_mapping_filename</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional path to a custom data mapping file.</p>"},{"location":"api/infrastructure/process/","title":"Process","text":""},{"location":"api/infrastructure/process/#icecap.infrastructure.process","title":"icecap.infrastructure.process","text":"<p>Classes:</p> <ul> <li> <code>GameProcessManager</code>           \u2013            <p>The service encapsulates interaction with the OS process layer.</p> </li> </ul>"},{"location":"api/infrastructure/process/#icecap.infrastructure.process.GameProcessManager","title":"GameProcessManager","text":"<p>               Bases: <code>Protocol</code></p> <p>The service encapsulates interaction with the OS process layer.</p>"},{"location":"api/infrastructure/process/#icecap.infrastructure.process.GameProcessManager.get_process_id","title":"get_process_id","text":"<pre><code>get_process_id() -&gt; int | None\n</code></pre> <p>Locate the game process ID.</p>"},{"location":"api/infrastructure/process/#icecap.infrastructure.process.GameProcessManager.pid_changed_since_last_call","title":"pid_changed_since_last_call","text":"<pre><code>pid_changed_since_last_call() -&gt; bool\n</code></pre> <p>Check if the game process ID changed since the last call.</p> <p>This is used to detect when the game process has been recreated.</p>"},{"location":"api/infrastructure/process/#icecap.infrastructure.process.get_game_process_manager","title":"get_game_process_manager","text":"<pre><code>get_game_process_manager(\n    game_process_name: str = WOW_PROCESS_NAME,\n) -&gt; GameProcessManager\n</code></pre> <p>Game process manager factory.</p>"},{"location":"api/infrastructure/repository/","title":"Repository","text":""},{"location":"api/infrastructure/repository/#icecap.infrastructure.repository","title":"icecap.infrastructure.repository","text":"<p>This module provides repository classes for accessing different types of game entities.</p> <p>The repositories abstract the data access layer and provide a clean interface for retrieving and manipulating game entities.</p> <p>Classes:</p> <ul> <li> <code>GameObjectRepository</code>           \u2013            <p>Repository for game object entities.</p> </li> <li> <code>PlayerRepository</code>           \u2013            <p>Repository for player entities.</p> </li> <li> <code>UnitRepository</code>           \u2013            <p>Repository for unit entities.</p> </li> </ul>"},{"location":"api/infrastructure/repository/#icecap.infrastructure.repository.GameObjectRepository","title":"GameObjectRepository","text":"<pre><code>GameObjectRepository(driver: GameDriver)\n</code></pre> <p>Repository for game object entities.</p> <p>This class provides methods to access game object entities in the game.</p> Source code in <code>icecap/infrastructure/repository/game_object_repository.py</code> <pre><code>def __init__(self, driver: GameDriver):\n    self.driver = driver\n</code></pre>"},{"location":"api/infrastructure/repository/#icecap.infrastructure.repository.GameObjectRepository.get_game_object_from_entity","title":"get_game_object_from_entity","text":"<pre><code>get_game_object_from_entity(\n    entity: Entity,\n    object_manager: ObjectManager | None = None,\n    name_resolver: NameResolver | None = None,\n) -&gt; GameObject\n</code></pre> <p>Extends an Entity object to a GameObject instance.</p> <p>This method takes an Entity object, extracts all the necessary information and creates a GameObject object from it.</p> <p>You can bring your own name resolver and object manager.</p> Source code in <code>icecap/infrastructure/repository/game_object_repository.py</code> <pre><code>def get_game_object_from_entity(\n    self,\n    entity: Entity,\n    object_manager: ObjectManager | None = None,\n    name_resolver: NameResolver | None = None,\n) -&gt; GameObject:\n    \"\"\"Extends an Entity object to a GameObject instance.\n\n    This method takes an Entity object, extracts all the necessary information\n    and creates a GameObject object from it.\n\n    You can bring your own name resolver and object manager.\n    \"\"\"\n    object_manager = object_manager or self.driver.object_manager\n    name_resolver = name_resolver or self.driver.name_resolver\n\n    position = object_manager.get_entity_position(entity)\n    game_object_fields = object_manager.get_game_object_fields(entity)\n    name = name_resolver.resolve_game_object_name_by_entry_id(game_object_fields.entry)\n\n    game_object = GameObject(\n        guid=entity.guid,\n        object_address=entity.object_address,\n        position=Position(x=position.x, y=position.y, z=position.z, rotation=position.rotation),\n        name=name,\n        entity_type=EntityType.GAME_OBJECT,\n        game_object_fields=GameObjectFields(\n            entry_id=game_object_fields.entry,\n            display_id=game_object_fields.display_id,\n            owner_guid=game_object_fields.created_by,\n            state=game_object_fields.bytes1_state,\n        ),\n    )\n    return game_object\n</code></pre>"},{"location":"api/infrastructure/repository/#icecap.infrastructure.repository.GameObjectRepository.refresh_game_object","title":"refresh_game_object","text":"<pre><code>refresh_game_object(game_object: GameObject) -&gt; GameObject\n</code></pre> <p>Refresh the game object data with the latest information from the game.</p> <p>This method retrieves the latest data for a game object from the game and returns a new GameObject instance with the updated data. The original GameObject instance is not modified.</p> Source code in <code>icecap/infrastructure/repository/game_object_repository.py</code> <pre><code>def refresh_game_object(self, game_object: GameObject) -&gt; GameObject:\n    \"\"\"Refresh the game object data with the latest information from the game.\n\n    This method retrieves the latest data for a game object from the game and\n    returns a new GameObject instance with the updated data. The original GameObject\n    instance is not modified.\n    \"\"\"\n    object_manager = self.driver.object_manager\n\n    position = object_manager.get_entity_position(game_object)\n    game_object_fields = object_manager.get_game_object_fields(game_object)\n\n    return GameObject(\n        guid=game_object.guid,\n        object_address=game_object.object_address,\n        position=Position(x=position.x, y=position.y, z=position.z, rotation=position.rotation),\n        name=game_object.name,\n        entity_type=EntityType.GAME_OBJECT,\n        game_object_fields=GameObjectFields(\n            entry_id=game_object_fields.entry,\n            display_id=game_object_fields.display_id,\n            owner_guid=game_object_fields.created_by,\n            state=game_object_fields.bytes1_state,\n        ),\n    )\n</code></pre>"},{"location":"api/infrastructure/repository/#icecap.infrastructure.repository.GameObjectRepository.yield_game_objects","title":"yield_game_objects","text":"<pre><code>yield_game_objects() -&gt; Generator[GameObject, None, None]\n</code></pre> <p>Yield all game object entities around the local player.</p> <p>This method iterates through all objects around the player and yields only those that are of type GAME_OBJECT. Each entity is extended to a GameObject object before being yielded.</p> Source code in <code>icecap/infrastructure/repository/game_object_repository.py</code> <pre><code>def yield_game_objects(self) -&gt; Generator[GameObject, None, None]:\n    \"\"\"Yield all game object entities around the local player.\n\n    This method iterates through all objects around the player and yields\n    only those that are of type GAME_OBJECT. Each entity is extended to a\n    GameObject object before being yielded.\n    \"\"\"\n    object_manager = self.driver.object_manager\n    name_resolver = self.driver.name_resolver\n\n    for entity in object_manager.yield_objects():\n        if entity.entity_type != EntityType.GAME_OBJECT:\n            continue\n\n        yield self.get_game_object_from_entity(entity, object_manager, name_resolver)\n</code></pre>"},{"location":"api/infrastructure/repository/#icecap.infrastructure.repository.PlayerRepository","title":"PlayerRepository","text":"<pre><code>PlayerRepository(driver: GameDriver)\n</code></pre> <p>Repository for player entities.</p> <p>This class provides methods to access player entities in the game.</p> Source code in <code>icecap/infrastructure/repository/player_repository.py</code> <pre><code>def __init__(self, driver: GameDriver):\n    self.driver = driver\n</code></pre>"},{"location":"api/infrastructure/repository/#icecap.infrastructure.repository.PlayerRepository.get_local_player","title":"get_local_player","text":"<pre><code>get_local_player() -&gt; Player\n</code></pre> <p>Retrieve the local player entity (the user's character).</p> <p>It uses the object manager to get the local player's GUID and then searches for the corresponding entity.</p> Source code in <code>icecap/infrastructure/repository/player_repository.py</code> <pre><code>def get_local_player(self) -&gt; Player:\n    \"\"\"Retrieve the local player entity (the user's character).\n\n    It uses the object manager to get the local player's\n    GUID and then searches for the corresponding entity.\n    \"\"\"\n    object_manager = self.driver.object_manager\n    name_resolver = self.driver.name_resolver\n\n    local_player_guid = object_manager.get_local_player_guid()\n\n    for entity in object_manager.yield_objects():\n        if entity.guid == local_player_guid:\n            return self.get_player_from_entity(entity, object_manager, name_resolver)\n\n    raise ValueError(\"Local player not found in the object manager.\")\n</code></pre>"},{"location":"api/infrastructure/repository/#icecap.infrastructure.repository.PlayerRepository.get_player_from_entity","title":"get_player_from_entity","text":"<pre><code>get_player_from_entity(\n    entity: Entity,\n    object_manager: ObjectManager | None = None,\n    name_resolver: NameResolver | None = None,\n) -&gt; Player\n</code></pre> <p>Extend an Entity object to a Player object.</p> <p>This method takes an Entity object and extracts all the necessary information to create a Player object.</p> Source code in <code>icecap/infrastructure/repository/player_repository.py</code> <pre><code>def get_player_from_entity(\n    self,\n    entity: Entity,\n    object_manager: ObjectManager | None = None,\n    name_resolver: NameResolver | None = None,\n) -&gt; Player:\n    \"\"\"Extend an Entity object to a Player object.\n\n    This method takes an Entity object and extracts all the necessary information\n    to create a Player object.\n    \"\"\"\n    object_manager = object_manager or self.driver.object_manager\n    name_resolver = name_resolver or self.driver.name_resolver\n\n    position = object_manager.get_entity_position(entity)\n    name = name_resolver.resolve_name(entity)\n\n    unit_fields = object_manager.get_unit_fields(entity)\n    race = Race(unit_fields.bytes_0_race)\n\n    player = Player(\n        guid=entity.guid,\n        object_address=entity.object_address,\n        position=Position(x=position.x, y=position.y, z=position.z, rotation=position.rotation),\n        name=name,\n        entity_type=EntityType.PLAYER,\n        unit_fields=UnitFields(\n            level=unit_fields.level,\n            hit_points=unit_fields.health,\n            max_hit_points=unit_fields.max_health,\n            faction=Faction.from_race(race),\n            race=race,\n            player_class=PlayerClass(unit_fields.bytes_0_class),\n            gender=Gender(unit_fields.bytes_0_gender),\n            channel_object=unit_fields.channel_object,\n            channel_spell=unit_fields.channel_spell,\n        ),\n    )\n    return player\n</code></pre>"},{"location":"api/infrastructure/repository/#icecap.infrastructure.repository.PlayerRepository.refresh_player","title":"refresh_player","text":"<pre><code>refresh_player(player: Player) -&gt; Player\n</code></pre> <p>Refresh the player data with the latest information from the game.</p> <p>This method retrieves the latest data for a player from the game and returns a new Player instance with the updated data. The original Player instance is not modified.</p> Source code in <code>icecap/infrastructure/repository/player_repository.py</code> <pre><code>def refresh_player(self, player: Player) -&gt; Player:\n    \"\"\"Refresh the player data with the latest information from the game.\n\n    This method retrieves the latest data for a player from the game and\n    returns a new Player instance with the updated data. The original Player\n    instance is not modified.\n    \"\"\"\n    object_manager = self.driver.object_manager\n\n    position = object_manager.get_entity_position(player)\n    unit_fields = object_manager.get_unit_fields(player)\n\n    return Player(\n        guid=player.guid,\n        object_address=player.object_address,\n        position=Position(x=position.x, y=position.y, z=position.z, rotation=position.rotation),\n        name=player.name,\n        entity_type=EntityType.PLAYER,\n        unit_fields=UnitFields(\n            level=unit_fields.level,\n            hit_points=unit_fields.health,\n            max_hit_points=unit_fields.max_health,\n            faction=player.unit_fields.faction,\n            race=player.unit_fields.race,\n            player_class=player.unit_fields.player_class,\n            gender=player.unit_fields.gender,\n        ),\n    )\n</code></pre>"},{"location":"api/infrastructure/repository/#icecap.infrastructure.repository.PlayerRepository.yield_players","title":"yield_players","text":"<pre><code>yield_players() -&gt; Generator[Player, None, None]\n</code></pre> <p>Yield all player entities around the local player.</p> <p>This method iterates through all objects around the local player and yields only those that are of type PLAYER. Each entity is extended to a Player object before being yielded.</p> Source code in <code>icecap/infrastructure/repository/player_repository.py</code> <pre><code>def yield_players(self) -&gt; Generator[Player, None, None]:\n    \"\"\"Yield all player entities around the local player.\n\n    This method iterates through all objects around the local player and yields\n    only those that are of type PLAYER. Each entity is extended to a Player object\n    before being yielded.\n    \"\"\"\n    object_manager = self.driver.object_manager\n    name_resolver = self.driver.name_resolver\n\n    for entity in object_manager.yield_objects():\n        if entity.entity_type != EntityType.PLAYER:\n            continue\n\n        yield self.get_player_from_entity(entity, object_manager, name_resolver)\n</code></pre>"},{"location":"api/infrastructure/repository/#icecap.infrastructure.repository.UnitRepository","title":"UnitRepository","text":"<pre><code>UnitRepository(driver: GameDriver)\n</code></pre> <p>Repository for unit entities.</p> <p>This class provides methods to access unit entities in the game.</p> Source code in <code>icecap/infrastructure/repository/unit_repository.py</code> <pre><code>def __init__(self, driver: GameDriver):\n    self.driver = driver\n</code></pre>"},{"location":"api/infrastructure/repository/#icecap.infrastructure.repository.UnitRepository.get_unit_from_entity","title":"get_unit_from_entity","text":"<pre><code>get_unit_from_entity(\n    entity: Entity,\n    object_manager: ObjectManager | None = None,\n    name_resolver: NameResolver | None = None,\n) -&gt; Unit\n</code></pre> <p>Extend an Entity object to a Unit object.</p> <p>This method takes an Entity object and extracts all the necessary information and creates a Unit object from it.</p> Source code in <code>icecap/infrastructure/repository/unit_repository.py</code> <pre><code>def get_unit_from_entity(\n    self,\n    entity: Entity,\n    object_manager: ObjectManager | None = None,\n    name_resolver: NameResolver | None = None,\n) -&gt; Unit:\n    \"\"\"Extend an Entity object to a Unit object.\n\n    This method takes an Entity object and extracts all the necessary information\n    and creates a Unit object from it.\n    \"\"\"\n    object_manager = object_manager or self.driver.object_manager\n    name_resolver = name_resolver or self.driver.name_resolver\n\n    position = object_manager.get_entity_position(entity)\n    name = name_resolver.resolve_name(entity)\n\n    unit_fields = object_manager.get_unit_fields(entity)\n    race = Race(unit_fields.bytes_0_race)\n\n    unit = Unit(\n        guid=entity.guid,\n        object_address=entity.object_address,\n        position=Position(x=position.x, y=position.y, z=position.z, rotation=position.rotation),\n        name=name,\n        entity_type=EntityType.UNIT,\n        unit_fields=UnitFields(\n            level=unit_fields.level,\n            hit_points=unit_fields.health,\n            max_hit_points=unit_fields.max_health,\n            faction=Faction.from_race(race),\n            race=race,\n            player_class=PlayerClass(unit_fields.bytes_0_class),\n            gender=Gender(unit_fields.bytes_0_gender),\n        ),\n    )\n    return unit\n</code></pre>"},{"location":"api/infrastructure/repository/#icecap.infrastructure.repository.UnitRepository.refresh_unit","title":"refresh_unit","text":"<pre><code>refresh_unit(unit: Unit) -&gt; Unit\n</code></pre> <p>Refresh the unit data with the latest information from the game.</p> <p>This method retrieves the latest data for a unit from the game and returns a new Unit instance with the updated data. The original Unit instance is not modified.</p> Source code in <code>icecap/infrastructure/repository/unit_repository.py</code> <pre><code>def refresh_unit(self, unit: Unit) -&gt; Unit:\n    \"\"\"Refresh the unit data with the latest information from the game.\n\n    This method retrieves the latest data for a unit from the game and\n    returns a new Unit instance with the updated data. The original Unit\n    instance is not modified.\n    \"\"\"\n    object_manager = self.driver.object_manager\n\n    position = object_manager.get_entity_position(unit)\n    unit_fields = object_manager.get_unit_fields(unit)\n\n    return Unit(\n        guid=unit.guid,\n        object_address=unit.object_address,\n        position=Position(x=position.x, y=position.y, z=position.z, rotation=position.rotation),\n        name=unit.name,\n        entity_type=EntityType.UNIT,\n        unit_fields=UnitFields(\n            level=unit_fields.level,\n            hit_points=unit_fields.health,\n            max_hit_points=unit_fields.max_health,\n            faction=unit.unit_fields.faction,\n            race=unit.unit_fields.race,\n            player_class=unit.unit_fields.player_class,\n            gender=unit.unit_fields.gender,\n        ),\n    )\n</code></pre>"},{"location":"api/infrastructure/repository/#icecap.infrastructure.repository.UnitRepository.yield_units","title":"yield_units","text":"<pre><code>yield_units() -&gt; Generator[Unit, None, None]\n</code></pre> <p>Yield all unit entities around the player.</p> <p>This method iterates through all objects around the player and yields only those that are of type UNIT. Each entity is extended to a Unit object before being yielded.</p> Source code in <code>icecap/infrastructure/repository/unit_repository.py</code> <pre><code>def yield_units(self) -&gt; Generator[Unit, None, None]:\n    \"\"\"Yield all unit entities around the player.\n\n    This method iterates through all objects around the player and yields\n    only those that are of type UNIT. Each entity is extended to a Unit object\n    before being yielded.\n    \"\"\"\n    object_manager = self.driver.object_manager\n    name_resolver = self.driver.name_resolver\n\n    for entity in object_manager.yield_objects():\n        if entity.entity_type != EntityType.UNIT:\n            continue\n\n        yield self.get_unit_from_entity(entity, object_manager, name_resolver)\n</code></pre>"},{"location":"api/infrastructure/resource/","title":"Resource","text":""},{"location":"api/infrastructure/resource/#icecap.infrastructure.resource","title":"icecap.infrastructure.resource","text":"<p>The module provides tooling to manipulate game assets.</p> <p>World of Warcraft assets are stored in MPQ archives. Depending on the archive name, the assets are loaded with different priorities.</p> <p>Currently, the module provides tools to load MPQ archives, list and extract individual files from the archives.</p> <p>Classes:</p> <ul> <li> <code>MPQArchive</code>           \u2013            <p>Represents an MPQ archive.</p> </li> <li> <code>MPQArchiveChain</code>           \u2013            <p>The class allows reading files from multiple archives in a priority order.</p> </li> </ul>"},{"location":"api/infrastructure/resource/#icecap.infrastructure.resource.MPQArchive","title":"MPQArchive","text":"<pre><code>MPQArchive(path: str)\n</code></pre> <p>Represents an MPQ archive.</p> <p>MPQ is a proprietary archive format used by Blizzard Entertainment. Read more about it here: https://wowdev.wiki/MPQ</p> <p>The implementation is very naive and most likely won't work with post-WOTLK expansions.</p> Source code in <code>icecap/infrastructure/resource/mpq/archive.py</code> <pre><code>def __init__(self, path: str):\n    self.file_path = path\n\n    self.file = open(path, \"rb\")\n    self.crypt = Crypt()\n\n    self._header: Header | None = None\n    self._hash_table: HashTable | None = None\n    self._block_table: BlockTable | None = None\n    self._file_names: list[str] | None = None\n</code></pre>"},{"location":"api/infrastructure/resource/#icecap.infrastructure.resource.MPQArchive.file_exists","title":"file_exists","text":"<pre><code>file_exists(filename: str) -&gt; bool\n</code></pre> <p>Check if a file exists in the archive.</p> Source code in <code>icecap/infrastructure/resource/mpq/archive.py</code> <pre><code>def file_exists(self, filename: str) -&gt; bool:\n    \"\"\"Check if a file exists in the archive.\"\"\"\n    return self.get_hash_table_entry(filename) is not None\n</code></pre>"},{"location":"api/infrastructure/resource/#icecap.infrastructure.resource.MPQArchive.get_block_table","title":"get_block_table","text":"<pre><code>get_block_table() -&gt; BlockTable\n</code></pre> <p>Get the block table of the archive.</p> <p>The block table contains metadata about the position and size of each file in the archive.</p> Source code in <code>icecap/infrastructure/resource/mpq/archive.py</code> <pre><code>def get_block_table(self) -&gt; BlockTable:\n    \"\"\"Get the block table of the archive.\n\n    The block table contains metadata about the position and size of each file in the archive.\n    \"\"\"\n    if self._block_table:\n        return self._block_table\n\n    header = self.get_header()\n\n    key = self.crypt.hash(\"(block table)\", HashType.TABLE)\n\n    self.file.seek(header.block_table_offset)\n    data = self.file.read(header.block_table_size * 16)\n    data = self.crypt.decrypt(data, key)\n\n    def unpack_entry(position):\n        entry_data = data[position * 16 : position * 16 + 16]\n        return BlockTableEntry(*struct.unpack(\"&lt;4I\", entry_data))\n\n    self._block_table = BlockTable([unpack_entry(i) for i in range(header.block_table_size)])\n    return self._block_table\n</code></pre>"},{"location":"api/infrastructure/resource/#icecap.infrastructure.resource.MPQArchive.get_file_names","title":"get_file_names","text":"<pre><code>get_file_names() -&gt; list[str]\n</code></pre> <p>Get a list of file names in the archive.</p> <p>The list is lazily loaded the first time this method is called.</p> Source code in <code>icecap/infrastructure/resource/mpq/archive.py</code> <pre><code>def get_file_names(self) -&gt; list[str]:\n    \"\"\"Get a list of file names in the archive.\n\n    The list is lazily loaded the first time this method is called.\n    \"\"\"\n    if self._file_names:\n        return self._file_names\n\n    listfile_data = self.read_file(\"(listfile)\")\n\n    if listfile_data is None:\n        self._file_names = []\n        return self._file_names\n\n    self._file_names = listfile_data.decode().splitlines()\n\n    return self._file_names\n</code></pre>"},{"location":"api/infrastructure/resource/#icecap.infrastructure.resource.MPQArchive.get_hash_table","title":"get_hash_table","text":"<pre><code>get_hash_table() -&gt; HashTable\n</code></pre> <p>Get the hash table of the archive.</p> <p>This is a classical hash table used to quickly locate files in the archive.</p> Source code in <code>icecap/infrastructure/resource/mpq/archive.py</code> <pre><code>def get_hash_table(self) -&gt; HashTable:\n    \"\"\"Get the hash table of the archive.\n\n    This is a classical hash table used to quickly locate files in the archive.\n    \"\"\"\n    if self._hash_table:\n        return self._hash_table\n\n    header = self.get_header()\n\n    key = self.crypt.hash(\"(hash table)\", HashType.TABLE)\n\n    self.file.seek(header.hash_table_offset)\n    data = self.file.read(header.hash_table_size * 16)\n    data = self.crypt.decrypt(data, key)\n\n    def unpack_entry(position):\n        entry_data = data[position * 16 : position * 16 + 16]\n        return HashTableEntry(*struct.unpack(\"&lt;2I2HI\", entry_data))\n\n    self._hash_table = HashTable([unpack_entry(i) for i in range(header.hash_table_size)])\n    return self._hash_table\n</code></pre>"},{"location":"api/infrastructure/resource/#icecap.infrastructure.resource.MPQArchive.get_hash_table_entry","title":"get_hash_table_entry","text":"<pre><code>get_hash_table_entry(filename: str) -&gt; HashTableEntry | None\n</code></pre> <p>Get the hash table entry corresponding to a given filename.</p> Source code in <code>icecap/infrastructure/resource/mpq/archive.py</code> <pre><code>def get_hash_table_entry(self, filename: str) -&gt; HashTableEntry | None:\n    \"\"\"Get the hash table entry corresponding to a given filename.\"\"\"\n    hash_a = self.crypt.hash(filename, HashType.HASH_A)\n    hash_b = self.crypt.hash(filename, HashType.HASH_B)\n\n    for entry in self.get_hash_table().entries:\n        if entry.name1 == hash_a and entry.name2 == hash_b:\n            return entry\n\n    return None\n</code></pre>"},{"location":"api/infrastructure/resource/#icecap.infrastructure.resource.MPQArchive.get_header","title":"get_header","text":"<pre><code>get_header() -&gt; Header\n</code></pre> <p>Get the MPQ header.</p> <p>The header contains metadata about the archive. The header is lazily loaded the first time this method is called.</p> Source code in <code>icecap/infrastructure/resource/mpq/archive.py</code> <pre><code>def get_header(self) -&gt; Header:\n    \"\"\"Get the MPQ header.\n\n    The header contains metadata about the archive.\n    The header is lazily loaded the first time this method is called.\n    \"\"\"\n    if self._header:\n        return self._header\n\n    magic = self.file.read(4)\n    self.file.seek(0)\n\n    if magic == b\"MPQ\\x1b\":\n        raise ValueError(\"MPQ shunts are not supported.\")\n    elif magic != b\"MPQ\\x1a\":\n        raise ValueError(\"Invalid MPQ header.\")\n\n    data = self.file.read(32)\n    header = Header(*struct.unpack(\"&lt;4s2I2H4I\", data))\n    if header.format_version == 1:\n        header_extension_data = self.file.read(12)\n        header.extension = HeaderExtension(*struct.unpack(\"&lt;q2h\", header_extension_data))\n    if header.format_version &gt; 1:\n        raise ValueError(\"Unsupported MPQ format version.\")\n\n    self._header = header\n    return self._header\n</code></pre>"},{"location":"api/infrastructure/resource/#icecap.infrastructure.resource.MPQArchive.read_file","title":"read_file","text":"<pre><code>read_file(filename: str) -&gt; bytes | None\n</code></pre> <p>Read a file from the MPQ archive.</p> Source code in <code>icecap/infrastructure/resource/mpq/archive.py</code> <pre><code>def read_file(self, filename: str) -&gt; bytes | None:\n    \"\"\"\n    Read a file from the MPQ archive.\n    \"\"\"\n    # Get file metadata\n    hash_entry = self.get_hash_table_entry(filename)\n    if hash_entry is None:\n        return None\n\n    header = self.get_header()\n    block_table = self.get_block_table()\n    block_entry = block_table.entries[hash_entry.block_index]\n\n    # Check if the file exists and has content\n    if not (block_entry.flags &amp; MPQ_FILE_EXISTS):\n        return None\n\n    if block_entry.compressed_size == 0:\n        return None\n\n    # Read file resource\n    self.file.seek(block_entry.file_position)\n    file_data = self.file.read(block_entry.compressed_size)\n\n    # Check for encryption\n    if block_entry.flags &amp; MPQ_FILE_ENCRYPTED:\n        raise NotImplementedError(\"Encryption is not supported yet.\")\n\n    # Process file based on its structure\n    if block_entry.flags &amp; MPQ_FILE_SINGLE_UNIT:\n        return self._process_single_unit_file(file_data, block_entry)\n    else:\n        return self._process_multi_sector_file(file_data, block_entry, header.block_size)\n</code></pre>"},{"location":"api/infrastructure/resource/#icecap.infrastructure.resource.MPQArchiveChain","title":"MPQArchiveChain","text":"<pre><code>MPQArchiveChain(archive_priorities: tuple[str, ...] = WOW_ARCHIVE_PRIORITIES)\n</code></pre> <p>The class allows reading files from multiple archives in a priority order.</p> <p>The service checks the highest priority archive first.</p> <p>Default priorities are set to the WOW archive name priorities.</p> Source code in <code>icecap/infrastructure/resource/mpq/chain.py</code> <pre><code>def __init__(self, archive_priorities: tuple[str, ...] = WOW_ARCHIVE_PRIORITIES):\n    self._prioritized_archives: dict[int, list[MPQArchive]] = {}\n    self._archive_priorities: list[re.Pattern] = [\n        re.compile(pattern) for pattern in archive_priorities\n    ]\n</code></pre>"},{"location":"api/infrastructure/resource/#icecap.infrastructure.resource.MPQArchiveChain.add_archive","title":"add_archive","text":"<pre><code>add_archive(archive: MPQArchive)\n</code></pre> <p>Add an archive to the chain.</p> Source code in <code>icecap/infrastructure/resource/mpq/chain.py</code> <pre><code>def add_archive(self, archive: MPQArchive):\n    \"\"\"Add an archive to the chain.\"\"\"\n    archive_name = os.path.split(archive.file_path)[-1].lower().rstrip(\".mpq\")\n\n    for number, priority_regex in enumerate(self._archive_priorities):\n        if not priority_regex.match(archive_name):\n            continue\n\n        if not self._prioritized_archives.get(number):\n            self._prioritized_archives[number] = []\n\n        if archive not in self._prioritized_archives[number]:\n            self._prioritized_archives[number].append(archive)\n        return\n\n    raise ValueError(f\"Could not find a suitable priority for archive '{archive_name}'\")\n</code></pre>"},{"location":"api/infrastructure/resource/#icecap.infrastructure.resource.MPQArchiveChain.load_archives","title":"load_archives  <code>classmethod</code>","text":"<pre><code>load_archives(game_data_path: str) -&gt; MPQArchiveChain\n</code></pre> <p>Find all MPQ archives in the game_data_path and add them to an MPQArchiveChain.</p> Source code in <code>icecap/infrastructure/resource/mpq/chain.py</code> <pre><code>@classmethod\ndef load_archives(cls, game_data_path: str) -&gt; \"MPQArchiveChain\":\n    \"\"\"Find all MPQ archives in the game_data_path and add them to an MPQArchiveChain.\"\"\"\n    chain = MPQArchiveChain()\n\n    for root, _, files in os.walk(game_data_path):\n        for file in files:\n            if file.lower().endswith(MPQArchive.ARCHIVE_EXTENSION):\n                try:\n                    archive_path = os.path.join(root, file)\n                    archive = MPQArchive(archive_path)\n\n                    chain.add_archive(archive)\n                except Exception as e:\n                    raise ValueError(f\"Failed to load MPQ archive {file}: {e}\") from e\n\n    return chain\n</code></pre>"},{"location":"api/infrastructure/resource/#icecap.infrastructure.resource.MPQArchiveChain.read_file","title":"read_file","text":"<pre><code>read_file(filename: str) -&gt; bytes | None\n</code></pre> <p>Read a file from the chain.</p> <p>The file is searched in the archives in the priority order.</p> Source code in <code>icecap/infrastructure/resource/mpq/chain.py</code> <pre><code>def read_file(self, filename: str) -&gt; bytes | None:\n    \"\"\"Read a file from the chain.\n\n    The file is searched in the archives in the priority order.\n    \"\"\"\n    for priority in sorted(self._prioritized_archives.keys()):\n        for archive in self._prioritized_archives[priority]:\n            if archive.file_exists(filename):\n                return archive.read_file(filename)\n\n    return None\n</code></pre>"},{"location":"api/services/navigation/minimap/","title":"Minimap Service","text":"<p>This page documents the Minimap service and related DTOs.</p>"},{"location":"api/services/navigation/minimap/#dtos","title":"DTOs","text":""},{"location":"api/services/navigation/minimap/#icecap.services.navigation.minimap.dto","title":"icecap.services.navigation.minimap.dto","text":"<p>Classes:</p> <ul> <li> <code>Minimap</code>           \u2013            <p>Data class representing the minimap.</p> </li> </ul>"},{"location":"api/services/navigation/minimap/#icecap.services.navigation.minimap.dto.Minimap","title":"Minimap  <code>dataclass</code>","text":"<pre><code>Minimap(maps: dict[int, Map])\n</code></pre> <p>Data class representing the minimap.</p>"},{"location":"api/services/navigation/minimap/#icecap.services.navigation.minimap.dto.Minimap.render","title":"render","text":"<pre><code>render(map_id: int, position: Position, extent_pixels: int = 0) -&gt; Image\n</code></pre> <p>Render a minimap centered at the given position with the specified radius in pixels.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Image</code>           \u2013            <p>A PIL Image of the minimap centered on the position</p> </li> </ul> Source code in <code>icecap/services/navigation/minimap/dto.py</code> <pre><code>def render(self, map_id: int, position: Position, extent_pixels: int = 0) -&gt; PILImage:\n    \"\"\"\n    Render a minimap centered at the given position with the specified radius in pixels.\n\n    Args:\n        map_id: The ID of the map\n        position: The center position (entity position)\n        extent_pixels: The extent in pixels (0 for a single tile)\n\n    Returns:\n        A PIL Image of the minimap centered on the position\n    \"\"\"\n    map_obj = self.maps.get(map_id)\n    if map_obj is None:\n        return Image.new(\n            \"RGBA\",\n            (2 * extent_pixels, 2 * extent_pixels)\n            if extent_pixels &gt; 0\n            else (MINIMAP_TILE_SIZE, MINIMAP_TILE_SIZE),\n            (0, 0, 0, 0),\n        )\n\n    # Convert position to MapPosition\n    map_position = MapPosition.from_entity_position(position)\n\n    # Calculate the exact position within the tile\n    exact_x = (MAX_MAP_COORDINATE - position.x) / WORLD_TILE_SIZE\n    exact_y = (MAX_MAP_COORDINATE - position.y) / WORLD_TILE_SIZE\n\n    # Calculate the pixel offset within the tile\n    pixel_offset_x = (exact_x - int(exact_x)) * MINIMAP_TILE_SIZE\n    pixel_offset_y = (exact_y - int(exact_y)) * MINIMAP_TILE_SIZE\n\n    if extent_pixels == 0:\n        tile = map_obj.tiles.get(map_position)\n        if tile is None:\n            return Image.new(\"RGBA\", (MINIMAP_TILE_SIZE, MINIMAP_TILE_SIZE), (0, 0, 0, 0))\n\n        return tile.image\n\n    # Calculate how many tiles we need in each direction\n    tiles_needed_x = (extent_pixels + pixel_offset_x) // MINIMAP_TILE_SIZE\n    tiles_needed_y = (extent_pixels + pixel_offset_y) // MINIMAP_TILE_SIZE\n    tiles_needed = int(max(tiles_needed_x, tiles_needed_y))\n\n    # Calculate the size of the temporary image before cropping\n    matrix_size = 2 * tiles_needed + 1\n    temp_size = int(matrix_size * MINIMAP_TILE_SIZE)\n    temp_image = Image.new(\"RGBA\", (temp_size, temp_size), (0, 0, 0, 0))\n\n    for y_offset in range(-tiles_needed, tiles_needed + 1):\n        for x_offset in range(-tiles_needed, tiles_needed + 1):\n            current_pos = MapPosition(map_position.x + x_offset, map_position.y + y_offset)\n\n            tile = map_obj.tiles.get(current_pos)\n\n            matrix_x = x_offset + tiles_needed\n            matrix_y = y_offset + tiles_needed\n\n            pos_x = matrix_x * MINIMAP_TILE_SIZE\n            pos_y = matrix_y * MINIMAP_TILE_SIZE\n\n            if tile is not None:\n                tile_image = tile.image\n                temp_image.paste(tile_image, (pos_x, pos_y), tile_image)\n\n    center_x = tiles_needed * MINIMAP_TILE_SIZE + pixel_offset_x\n    center_y = tiles_needed * MINIMAP_TILE_SIZE + pixel_offset_y\n\n    # Calculate the crop box\n    left = int(center_x - extent_pixels)\n    top = int(center_y - extent_pixels)\n    right = int(center_x + extent_pixels)\n    bottom = int(center_y + extent_pixels)\n\n    return temp_image.crop((left, top, right, bottom))\n</code></pre>"},{"location":"api/services/navigation/minimap/#icecap.services.navigation.minimap.dto.Minimap.render(map_id)","title":"<code>map_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the map</p>"},{"location":"api/services/navigation/minimap/#icecap.services.navigation.minimap.dto.Minimap.render(position)","title":"<code>position</code>","text":"(<code>Position</code>)           \u2013            <p>The center position (entity position)</p>"},{"location":"api/services/navigation/minimap/#icecap.services.navigation.minimap.dto.Minimap.render(extent_pixels)","title":"<code>extent_pixels</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The extent in pixels (0 for a single tile)</p>"},{"location":"api/services/navigation/minimap/#service","title":"Service","text":""},{"location":"api/services/navigation/minimap/#icecap.services.navigation.minimap.service","title":"icecap.services.navigation.minimap.service","text":"<p>Classes:</p> <ul> <li> <code>MinimapService</code>           \u2013            <p>Provides tooling to manage and interact with the minimap system in the application.</p> </li> </ul>"},{"location":"api/services/navigation/minimap/#icecap.services.navigation.minimap.service.MinimapService","title":"MinimapService","text":"<pre><code>MinimapService(mpq_reader: MPQFileReader)\n</code></pre> <p>Provides tooling to manage and interact with the minimap system in the application.</p> <p>This class is designed to interact with map-related files to load, parse, and manage minimap data using data from the game's MPQ archive files.</p> Source code in <code>icecap/services/navigation/minimap/service.py</code> <pre><code>def __init__(self, mpq_reader: MPQFileReader):\n    self.mpq_reader = mpq_reader\n\n    self._md5_translate = self.load_md5_translate()\n    self._map_database = self.load_map_database()\n</code></pre>"},{"location":"api/services/navigation/minimap/#icecap.services.navigation.minimap.service.MinimapService.get_minimap","title":"get_minimap","text":"<pre><code>get_minimap() -&gt; Minimap\n</code></pre> <p>Constructs and returns a minimap containing map tiles for various map records.</p> <p>Returns:</p> <ul> <li> <code>Minimap</code> (              <code>Minimap</code> )          \u2013            <p>An object containing a collection of maps with their respective tiles.</p> </li> </ul> Source code in <code>icecap/services/navigation/minimap/service.py</code> <pre><code>def get_minimap(self) -&gt; Minimap:\n    \"\"\"\n    Constructs and returns a minimap containing map tiles for various map records.\n\n    Returns:\n        Minimap: An object containing a collection of maps with their respective tiles.\n    \"\"\"\n    maps: dict[int, Map] = {}\n    for record in self._map_database.get_records():\n        map_id = getattr(record, \"map_id\")\n        directory = getattr(record, \"directory\")\n        maps[map_id] = Map(map_id=map_id, tiles={})\n\n        for i in range(64):\n            for j in range(64):\n                texture_path = self.build_minimap_texture_path(directory, i, j)\n\n                if not texture_path:\n                    continue\n\n                map_position = MapPosition(x=i, y=j)\n                maps[map_id].tiles[map_position] = MapTile(\n                    position=map_position, texture_path=texture_path, mpq_reader=self.mpq_reader\n                )\n\n    return Minimap(maps=maps)\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Welcome to the Icecap tutorials section. Here you'll find guides and examples to help you get the most out of Icecap.</p>"},{"location":"tutorials/#available-tutorials","title":"Available Tutorials","text":""},{"location":"tutorials/#working-with-game-resources","title":"Working with Game Resources","text":"<ul> <li>Working with MPQ Archives - Learn how to work with MPQ files (WoW data files)</li> <li>Working with DBC Files - Learn how to work with DBC database files (WoW game data)</li> </ul>"},{"location":"tutorials/#navigation","title":"Navigation","text":"<ul> <li>Working with Minimap - Learn how to render World of Warcraft minimaps</li> </ul>"},{"location":"tutorials/#communication","title":"Communication","text":"<ul> <li>Interaction with Agent - Learn how to interact with the game process through the icecap agent</li> </ul>"},{"location":"tutorials/#coming-soon","title":"Coming Soon","text":"<p>More tutorials will be added in the future. Stay tuned!</p>"},{"location":"tutorials/assets/work_with_dbc/","title":"Working with DBC Files in Icecap","text":"<p>This guide will help you understand how to work with DBC (Database Container) files, which are database files used by Blizzard Entertainment games like World of Warcraft to store various game information.</p>"},{"location":"tutorials/assets/work_with_dbc/#what-are-dbc-files","title":"What are DBC Files?","text":"<p>DBC (Database Container) is a proprietary database format developed by Blizzard Entertainment for their games. These files contain structured data about various game elements such as maps, items, spells, creatures, and more. Understanding how to work with DBC files allows you to access and analyze game data for research or tool development.</p>"},{"location":"tutorials/assets/work_with_dbc/#basic-usage","title":"Basic Usage","text":""},{"location":"tutorials/assets/work_with_dbc/#opening-a-dbc-file","title":"Opening a DBC File","text":"<p>To work with a DBC file, you first need to open it using the <code>DBCFile</code> class and provide a row prototype that defines the structure of the records:</p> <pre><code>from icecap.infrastructure.resource import DBCFile, MapRowWithDefinitions\n\n# Open a DBC file using a predefined row prototype\ndbc_file = DBCFile(\"path/to/your/Map.dbc\", MapRowWithDefinitions)\n</code></pre>"},{"location":"tutorials/assets/work_with_dbc/#reading-records-from-a-dbc-file","title":"Reading Records from a DBC File","text":"<p>You can get all records from the DBC file:</p> <pre><code># Get all records from the DBC file\nrecords = dbc_file.get_records()\n\n# Print the first 5 records\nfor record in records[:5]:\n    print(f\"Map ID: {record.map_id}, Directory: {record.directory}, Instance Type: {record.instance_type}\")\n</code></pre>"},{"location":"tutorials/assets/work_with_dbc/#getting-file-header-information","title":"Getting File Header Information","text":"<p>You can access the header information of the DBC file:</p> <pre><code># Get the DBC file header\nheader = dbc_file.get_header()\n\n# Print header information\nprint(f\"Signature: {header.signature}\")\nprint(f\"Record Count: {header.record_count}\")\nprint(f\"Field Count: {header.field_count}\")\nprint(f\"Record Size: {header.record_size} bytes\")\nprint(f\"String Block Size: {header.string_block_size} bytes\")\n</code></pre>"},{"location":"tutorials/assets/work_with_dbc/#advanced-usage","title":"Advanced Usage","text":""},{"location":"tutorials/assets/work_with_dbc/#creating-custom-row-prototypes","title":"Creating Custom Row Prototypes","text":"<p>For each DBC file type, you need a row prototype that defines the structure of the records. Icecap provides <code>MapRowWithDefinitions</code> for Map.dbc, but you can create your own for other DBC files:</p> <pre><code>from dataclasses import dataclass, field\nfrom icecap.infrastructure.resource.dbc.dto import DBCRowWithDefinitions, DBCColumnDefinition\nfrom icecap.infrastructure.resource.dbc.enums import DBCFieldType\n\n@dataclass(frozen=True, slots=True)\nclass SpellRowWithDefinitions(DBCRowWithDefinitions):\n    spell_id: int = field(\n        metadata={\n            DBCRowWithDefinitions.METADATA_KEY: DBCColumnDefinition(\n                DBCFieldType.INT, is_primary_key=True\n            )\n        }\n    )\n    name: str = field(\n        metadata={DBCRowWithDefinitions.METADATA_KEY: DBCColumnDefinition(DBCFieldType.STRING)}\n    )\n    description: str = field(\n        metadata={DBCRowWithDefinitions.METADATA_KEY: DBCColumnDefinition(DBCFieldType.STRING)}\n    )\n    mana_cost: int = field(\n        metadata={DBCRowWithDefinitions.METADATA_KEY: DBCColumnDefinition(DBCFieldType.INT)}\n    )\n    # Add more fields as needed\n</code></pre>"},{"location":"tutorials/assets/work_with_dbc/#working-with-different-field-types","title":"Working with Different Field Types","text":"<p>DBC files support various field types:</p> <pre><code>from icecap.infrastructure.resource.dbc.enums import DBCFieldType\n\n# Available field types:\n# DBCFieldType.INT - 32-bit signed integer\n# DBCFieldType.UINT - 32-bit unsigned integer\n# DBCFieldType.FLOAT - 32-bit floating point\n# DBCFieldType.STRING - String reference\n# DBCFieldType.BOOLEAN - Boolean (0 or 1)\n# DBCFieldType.LOCALIZED_STRING - Multiple string references for different locales\n</code></pre>"},{"location":"tutorials/assets/work_with_dbc/#working-with-localized-strings","title":"Working with Localized Strings","text":"<p>Some DBC files contain localized strings for different languages. You can define a field as a localized string and access the values for different locales:</p> <pre><code>from dataclasses import dataclass, field\nfrom icecap.infrastructure.resource.dbc.dto import DBCRowWithDefinitions, DBCColumnDefinition\nfrom icecap.infrastructure.resource.dbc.enums import DBCFieldType, DBCLocale\n\n@dataclass(frozen=True, slots=True)\nclass ItemRowWithDefinitions(DBCRowWithDefinitions):\n    item_id: int = field(\n        metadata={\n            DBCRowWithDefinitions.METADATA_KEY: DBCColumnDefinition(\n                DBCFieldType.INT, is_primary_key=True\n            )\n        }\n    )\n    name: dict = field(\n        metadata={DBCRowWithDefinitions.METADATA_KEY: DBCColumnDefinition(DBCFieldType.LOCALIZED_STRING)}\n    )\n    # Add more fields as needed\n\n# Open the DBC file\ndbc_file = DBCFile(\"path/to/your/Item.dbc\", ItemRowWithDefinitions)\n\n# Get all records\nrecords = dbc_file.get_records()\n\n# Access localized strings\nfor record in records[:5]:\n    print(f\"Item ID: {record.item_id}\")\n    print(f\"Name (English): {record.name[DBCLocale.enUS]}\")\n    print(f\"Name (German): {record.name[DBCLocale.deDE]}\")\n    print(f\"Name (French): {record.name[DBCLocale.frFR]}\")\n    print()\n</code></pre>"},{"location":"tutorials/assets/work_with_dbc/#working-with-array-fields","title":"Working with Array Fields","text":"<p>Some DBC fields are arrays. You can define a field as an array by setting the <code>array_size</code> parameter:</p> <pre><code>from dataclasses import dataclass, field\nfrom icecap.infrastructure.resource.dbc.dto import DBCRowWithDefinitions, DBCColumnDefinition\nfrom icecap.infrastructure.resource.dbc.enums import DBCFieldType\n\n@dataclass(frozen=True, slots=True)\nclass SpellEffectRowWithDefinitions(DBCRowWithDefinitions):\n    spell_id: int = field(\n        metadata={\n            DBCRowWithDefinitions.METADATA_KEY: DBCColumnDefinition(\n                DBCFieldType.INT, is_primary_key=True\n            )\n        }\n    )\n    effect_values: list = field(\n        metadata={DBCRowWithDefinitions.METADATA_KEY: DBCColumnDefinition(DBCFieldType.INT, array_size=3)}\n    )\n    # Add more fields as needed\n</code></pre>"},{"location":"tutorials/assets/work_with_dbc/#complete-examples","title":"Complete Examples","text":""},{"location":"tutorials/assets/work_with_dbc/#example-1-reading-mapdbc","title":"Example 1: Reading Map.dbc","text":"<p>Here's a complete example that demonstrates how to open the Map.dbc file and read its contents:</p> <pre><code>from icecap.infrastructure.resource import DBCFile, MapRowWithDefinitions\n\n# Open the Map.dbc file\ndbc_file = DBCFile(\"path/to/your/Map.dbc\", MapRowWithDefinitions)\n\n# Get the header information\nheader = dbc_file.get_header()\nprint(f\"Map.dbc contains {header.record_count} maps\")\n\n# Get all records\nmaps = dbc_file.get_records()\n\n# Print information about each map\nfor map_record in maps:\n    print(f\"Map ID: {map_record.map_id}\")\n    print(f\"Directory: {map_record.directory}\")\n    print(f\"Instance Type: {map_record.instance_type}\")\n    print()\n\n# Find a specific map by ID\nazeroth_map = next((m for m in maps if m.map_id == 0), None)\nif azeroth_map:\n    print(f\"Found Azeroth map: {azeroth_map.directory}\")\n</code></pre>"},{"location":"tutorials/assets/work_with_dbc/#example-2-creating-a-custom-row-prototype-for-a-new-dbc-file","title":"Example 2: Creating a Custom Row Prototype for a New DBC File","text":"<p>Here's an example of creating a custom row prototype for a DBC file that isn't predefined in Icecap:</p> <pre><code>from dataclasses import dataclass, field\nfrom icecap.infrastructure.resource import DBCFile\nfrom icecap.infrastructure.resource.dbc.dto import DBCRowWithDefinitions, DBCColumnDefinition\nfrom icecap.infrastructure.resource.dbc.enums import DBCFieldType\n\n# Define a row prototype for AreaTable.dbc\n@dataclass(frozen=True, slots=True)\nclass AreaTableRowWithDefinitions(DBCRowWithDefinitions):\n    area_id: int = field(\n        metadata={\n            DBCRowWithDefinitions.METADATA_KEY: DBCColumnDefinition(\n                DBCFieldType.INT, is_primary_key=True\n            )\n        }\n    )\n    map_id: int = field(\n        metadata={DBCRowWithDefinitions.METADATA_KEY: DBCColumnDefinition(DBCFieldType.INT)}\n    )\n    parent_area_id: int = field(\n        metadata={DBCRowWithDefinitions.METADATA_KEY: DBCColumnDefinition(DBCFieldType.INT)}\n    )\n    area_name: str = field(\n        metadata={DBCRowWithDefinitions.METADATA_KEY: DBCColumnDefinition(DBCFieldType.STRING)}\n    )\n    flags: int = field(\n        metadata={DBCRowWithDefinitions.METADATA_KEY: DBCColumnDefinition(DBCFieldType.INT)}\n    )\n\n# Open the AreaTable.dbc file\ndbc_file = DBCFile(\"path/to/your/AreaTable.dbc\", AreaTableRowWithDefinitions)\n\n# Get all records\nareas = dbc_file.get_records()\n\n# Print information about each area\nfor area in areas[:10]:  # Print first 10 areas\n    print(f\"Area ID: {area.area_id}\")\n    print(f\"Map ID: {area.map_id}\")\n    print(f\"Parent Area ID: {area.parent_area_id}\")\n    print(f\"Area Name: {area.area_name}\")\n    print(f\"Flags: {area.flags}\")\n    print()\n\n# Find all areas in a specific map\nmap_id = 1  # Eastern Kingdoms\neastern_kingdoms_areas = [area for area in areas if area.map_id == map_id]\nprint(f\"Found {len(eastern_kingdoms_areas)} areas in Eastern Kingdoms\")\n</code></pre>"},{"location":"tutorials/assets/work_with_dbc/#next-steps","title":"Next Steps","text":"<p>Now that you understand how to work with DBC files, you can:</p> <ul> <li>Extract game data for analysis</li> <li>Create tools to browse and analyze DBC contents</li> <li>Build custom applications that use WoW game data</li> <li>Combine DBC data with other game resources like MPQ archives</li> </ul> <p>For more information about the DBC format and available DBC files in World of Warcraft, check out the WoWDev Wiki.</p>"},{"location":"tutorials/assets/work_with_mpq/","title":"Working with MPQ Archives in Icecap","text":"<p>This guide will help you understand how to work with MPQ (Mo'PaQ) archives, which are proprietary archive files used by Blizzard Entertainment games like World of Warcraft.</p>"},{"location":"tutorials/assets/work_with_mpq/#what-are-mpq-files","title":"What are MPQ Files?","text":"<p>MPQ (Mo'PaQ or Mike O'Brien Pack) is a proprietary archive format developed by Blizzard Entertainment for their games. These archives contain game data such as textures, models, sounds, and other resources. Understanding how to work with MPQ files allows you to extract and analyze game resources.</p>"},{"location":"tutorials/assets/work_with_mpq/#basic-usage","title":"Basic Usage","text":"<p>Use an external tool such as <code>MPQ editor</code> to browse the resources and explore the assets layout. Once you are ready to access the resources programmatically, proceed to the next sections.</p>"},{"location":"tutorials/assets/work_with_mpq/#opening-an-mpq-archive","title":"Opening an MPQ Archive","text":"<p>To work with an MPQ archive, you first need to open it using the <code>MPQArchive</code> class:</p> <pre><code>from icecap.infrastructure.resource.mpq.archive import MPQArchive\n\n# Open an MPQ archive\narchive = MPQArchive(\"path/to/your/archive.mpq\")\n</code></pre>"},{"location":"tutorials/assets/work_with_mpq/#listing-files-in-an-archive","title":"Listing Files in an Archive","text":"<p>You can get a list of all files contained in the archive:</p> <pre><code># Get a list of all files in the archive\nfile_list = archive.get_file_names()\n\n# Print the first 10 files\nfor filename in file_list[:10]:\n    print(filename)\n</code></pre>"},{"location":"tutorials/assets/work_with_mpq/#reading-files-from-an-archive","title":"Reading Files from an Archive","text":"<p>To read a specific file from the archive:</p> <pre><code># Read a file from the archive\nfilename = \"Textures/Minimap/md5translate.trs\"\nfile_data = archive.read_file(filename)\n\n# If the file is a text file, you can decode it\nif file_data:\n    text_content = file_data.decode()\n    print(text_content[:300])  # Print the first 300 characters\n</code></pre>"},{"location":"tutorials/assets/work_with_mpq/#checking-if-a-file-exists","title":"Checking if a File Exists","text":"<p>You can check if a specific file exists in the archive:</p> <pre><code># Check if a file exists\nfilename = \"Textures/Minimap/md5translate.trs\"\nif archive.file_exists(filename):\n    print(f\"The file '{filename}' exists in the archive.\")\nelse:\n    print(f\"The file '{filename}' does not exist in the archive.\")\n</code></pre>"},{"location":"tutorials/assets/work_with_mpq/#advanced-usage","title":"Advanced Usage","text":""},{"location":"tutorials/assets/work_with_mpq/#working-with-hash-functions","title":"Working with Hash Functions","text":"<p>MPQ archives use hash functions for file lookup. You can calculate these hashes for a filename:</p> <pre><code>from icecap.infrastructure.resource.mpq.enums import HashType\n\n# Calculate hash values for a filename\nfilename = \"Textures/Minimap/md5translate.trs\"\nhash_a = archive.crypt.hash(filename, HashType.HASH_A)\nhash_b = archive.crypt.hash(filename, HashType.HASH_B)\n\nprint(f\"Hash A: {hex(hash_a)}\")\nprint(f\"Hash B: {hex(hash_b)}\")\n</code></pre>"},{"location":"tutorials/assets/work_with_mpq/#accessing-archive-metadata","title":"Accessing Archive Metadata","text":"<p>You can access metadata about the archive:</p> <pre><code># Get the archive header\nheader = archive.get_header()\nprint(f\"Archive format version: {header.format_version}\")\nprint(f\"Block size: {header.block_size}\")\nprint(f\"Hash table size: {header.hash_table_size}\")\nprint(f\"Block table size: {header.block_table_size}\")\n\n# Get the hash table\nhash_table = archive.get_hash_table()\nprint(f\"Number of hash table entries: {len(hash_table.entries)}\")\n\n# Get the block table\nblock_table = archive.get_block_table()\nprint(f\"Number of block table entries: {len(block_table.entries)}\")\n</code></pre>"},{"location":"tutorials/assets/work_with_mpq/#understanding-file-flags","title":"Understanding File Flags","text":"<p>Files in MPQ archives have flags that indicate their properties:</p> <pre><code>from icecap.infrastructure.resource.mpq.flags import (\n    MPQ_FILE_EXISTS,\n    MPQ_FILE_ENCRYPTED,\n    MPQ_FILE_COMPRESS,\n    MPQ_FILE_SINGLE_UNIT,\n)\n\n# Get a hash table entry for a file\nhash_entry = archive.get_hash_table_entry(filename)\nif hash_entry:\n    # Get the corresponding block table entry\n    block_entry = archive.get_block_table().entries[hash_entry.block_index]\n\n    # Check file flags\n    print(f\"File exists: {bool(block_entry.flags &amp; MPQ_FILE_EXISTS)}\")\n    print(f\"File is encrypted: {bool(block_entry.flags &amp; MPQ_FILE_ENCRYPTED)}\")\n    print(f\"File is compressed: {bool(block_entry.flags &amp; MPQ_FILE_COMPRESS)}\")\n    print(f\"File is a single unit: {bool(block_entry.flags &amp; MPQ_FILE_SINGLE_UNIT)}\")\n\n    # Print file sizes\n    print(f\"Compressed size: {block_entry.compressed_size} bytes\")\n    print(f\"Uncompressed size: {block_entry.uncompressed_size} bytes\")\n</code></pre>"},{"location":"tutorials/assets/work_with_mpq/#complete-example","title":"Complete Example","text":"<p>Here's a complete example that demonstrates how to open an MPQ archive, list its contents, and read a specific file:</p> <pre><code>from icecap.infrastructure.resource.mpq.archive import MPQArchive\nfrom icecap.infrastructure.resource.mpq.enums import HashType\n\n# Open an MPQ archive\narchive = MPQArchive(\"path/to/your/archive.mpq\")\n\n# Get a list of all files in the archive\nfile_list = archive.get_file_names()\nprint(f\"The archive contains {len(file_list)} files.\")\n\n# Find files matching a pattern\ntexture_files = [f for f in file_list if f.startswith(\"Textures/\")]\nprint(f\"Found {len(texture_files)} texture files.\")\n\n# Read a specific file\nif texture_files:\n    filename = texture_files[0]\n    file_data = archive.read_file(filename)\n\n    if file_data:\n        print(f\"Successfully read '{filename}' ({len(file_data)} bytes)\")\n\n        # Calculate hash values for the filename\n        hash_a = archive.crypt.hash(filename, HashType.HASH_A)\n        hash_b = archive.crypt.hash(filename, HashType.HASH_B)\n\n        print(f\"Filename: {filename}\")\n        print(f\"Hash A: {hex(hash_a)}\")\n        print(f\"Hash B: {hex(hash_b)}\")\n</code></pre>"},{"location":"tutorials/assets/work_with_mpq/#working-with-archive-chains","title":"Working with Archive Chains","text":"<p>World of Warcraft uses multiple MPQ archives to store game data. These archives are loaded in a specific priority order, allowing newer content to override older content without replacing entire archives. This system is known as an \"archive chain.\"</p>"},{"location":"tutorials/assets/work_with_mpq/#understanding-archive-chains","title":"Understanding Archive Chains","text":"<p>In WoW, when the game needs to read a file, it checks multiple archives in order of priority:</p> <ol> <li>Patch archives (highest priority)</li> <li>Expansion-specific archives</li> <li>Base game archives</li> <li>Common archives (lowest priority)</li> </ol> <p>This allows game updates to modify only specific files while leaving the rest untouched. The <code>MPQArchiveChain</code> class in Icecap implements this same behavior.</p>"},{"location":"tutorials/assets/work_with_mpq/#creating-an-archive-chain","title":"Creating an Archive Chain","text":"<p>To work with multiple archives in a priority order, use the <code>MPQArchiveChain</code> class:</p> <pre><code>from icecap.infrastructure.resource.mpq import MPQArchiveChain\n\n# Create an archive chain with default WoW priorities\nchain = MPQArchiveChain()\n</code></pre>"},{"location":"tutorials/assets/work_with_mpq/#adding-archives-to-the-chain","title":"Adding Archives to the Chain","text":"<p>You can add multiple archives to the chain. The chain will automatically determine the priority based on the archive name:</p> <pre><code>from icecap.infrastructure.resource.mpq import MPQArchive, MPQArchiveChain\n\n# Create an archive chain\nchain = MPQArchiveChain()\n\n# Add archives to the chain\nbase_archive = MPQArchive(\"path/to/base.mpq\")\npatch_archive = MPQArchive(\"path/to/patch.mpq\")\n\nchain.add_archive(base_archive)\nchain.add_archive(patch_archive)\n</code></pre>"},{"location":"tutorials/assets/work_with_mpq/#reading-files-from-the-chain","title":"Reading Files from the Chain","text":"<p>When reading a file from the chain, it will check each archive in order of priority until it finds the file:</p> <pre><code># Read a file from the chain\nfilename = \"Textures/Minimap/md5translate.trs\"\nfile_data = chain.read_file(filename)\n\nif file_data:\n    print(f\"Successfully read '{filename}' from the archive chain\")\n</code></pre>"},{"location":"tutorials/assets/work_with_mpq/#understanding-wow-archive-priorities","title":"Understanding WoW Archive Priorities","text":"<p>The default priority system used by <code>MPQArchiveChain</code> matches the one used by World of Warcraft:</p> <pre><code>WOW_ARCHIVE_PRIORITIES = (\n    r\"patch-([a-z]+)-(\\d+)\",  # Highest priority (e.g., patch-enUS-3)\n    r\"patch-(\\d+)\",           # (e.g., patch-2)\n    \"patch\",                  # (e.g., patch.mpq)\n    r\"lichking-([a-z]+)\",     # (e.g., lichking-enUS)\n    r\"lichking\",              # (e.g., lichking.mpq)\n    r\"expansion-([-a-z]+)\",   # (e.g., expansion-enUS)\n    \"expansion\",              # (e.g., expansion.mpq)\n    r\"base-([a-z]+)\",         # (e.g., base-enUS)\n    \"base\",                   # (e.g., base.mpq)\n    r\"locale-([a-z]+)\",       # (e.g., locale-enUS)\n    r\"common-(\\d+)\",          # (e.g., common-2)\n    \"common\",                 # (e.g., common.mpq)\n    \".*\",                     # Lowest priority (any other archives)\n)\n</code></pre> <p>Archives are matched against these patterns in order, and the first match determines the archive's priority.</p>"},{"location":"tutorials/assets/work_with_mpq/#complete-chain-example","title":"Complete Chain Example","text":"<p>Here's a complete example that demonstrates how to use an archive chain to read files from multiple archives:</p> <pre><code>from icecap.infrastructure.resource.mpq import MPQArchive, MPQArchiveChain\n\n# Create an archive chain\nchain = MPQArchiveChain()\n\n# Add multiple archives to the chain\nbase_archive = MPQArchive(\"path/to/base.mpq\")\nexpansion_archive = MPQArchive(\"path/to/expansion.mpq\")\npatch_archive = MPQArchive(\"path/to/patch.mpq\")\n\n# Add archives to the chain (order doesn't matter as priority is determined by name)\nchain.add_archive(base_archive)\nchain.add_archive(expansion_archive)\nchain.add_archive(patch_archive)\n\n# Read a file that might exist in multiple archives\nfilename = \"Textures/Minimap/md5translate.trs\"\nfile_data = chain.read_file(filename)\n\nif file_data:\n    print(f\"Successfully read '{filename}' from the archive chain\")\n    print(f\"File size: {len(file_data)} bytes\")\n\n    # The chain automatically used the highest priority archive that contains the file\n    # In this case, if the file exists in patch.mpq, it will be read from there\n    # even if it also exists in base.mpq or expansion.mpq\n</code></pre>"},{"location":"tutorials/assets/work_with_mpq/#next-steps","title":"Next Steps","text":"<p>Now that you understand how to work with MPQ archives and archive chains, you can:</p> <ul> <li>Extract game resources for analysis</li> <li>Create tools to browse and extract MPQ contents</li> <li>Analyze game data for research purposes</li> <li>Work with multiple archives in the same way WoW does</li> </ul> <p>For more information about the MPQ format, check out the WoWDev Wiki.</p>"},{"location":"tutorials/communication/interact_with_agent/","title":"Interacting with the Icecap Agent","text":""},{"location":"tutorials/communication/interact_with_agent/#overview","title":"Overview","text":"<p>The icecap-agent is a DLL that can be injected into the World of Warcraft 3.3.5a client process, providing an asynchronous RPC interface for programmatic interaction with the game. The agent runs inside the game process and exposes a TCP server (default port 5050) that accepts Protocol Buffer-encoded commands and publishes events.</p>"},{"location":"tutorials/communication/interact_with_agent/#key-features","title":"Key Features","text":"<ul> <li>Embedded TCP Server: Listens on port 5050 for client connections</li> <li>Command Execution: Execute Lua code, read Lua variables, and control character movement</li> <li>Event Publishing: Asynchronous event notifications for command results</li> <li>Protocol Buffers: Type-safe message serialization</li> </ul>"},{"location":"tutorials/communication/interact_with_agent/#prerequisites","title":"Prerequisites","text":"<p>Before you can interact with the agent, you need to:</p> <ol> <li> <p>Get the icecap-agent DLL:    Download the latest release from icecap-agent releases</p> </li> <li> <p>Inject the DLL: Inject <code>injector.dll</code> into your running WoW 3.3.5a (build 12340) client using any DLL injector</p> </li> <li> <p>Verify injection: Check the logs at <code>%TEMP%\\icecap-agent\\icecap-agent.log</code></p> </li> <li> <p>Install icecap: Ensure you have the icecap Python package with RPC support</p> </li> </ol>"},{"location":"tutorials/communication/interact_with_agent/#getting-started","title":"Getting Started","text":""},{"location":"tutorials/communication/interact_with_agent/#connecting-to-the-agent","title":"Connecting to the Agent","text":"<p>The simplest way to connect to the agent is using the factory function:</p> <pre><code>from icecap.infrastructure.communication.rpc.factory import get_agent_client\n\n# Create the client\nagent_client = get_agent_client()\n\n# Connect to the agent (timeout defaults to 5.0 seconds)\nagent_client.connect()\n\n# Check if connected\nif agent_client.is_connected():\n    print(\"Connected to agent!\")\n</code></pre>"},{"location":"tutorials/communication/interact_with_agent/#closing-the-connection","title":"Closing the Connection","text":"<p>Always close the connection when you're done:</p> <pre><code>agent_client.close()\n</code></pre>"},{"location":"tutorials/communication/interact_with_agent/#available-commands","title":"Available Commands","text":"<p>The agent supports three types of commands, all defined in the corresponding .proto file:</p>"},{"location":"tutorials/communication/interact_with_agent/#1-lua-execute","title":"1. Lua Execute","text":"<p>Execute arbitrary Lua code in the game client. This does not return a value directly.</p> <pre><code>from uuid import uuid4\nfrom icecap.agent.v1.commands_pb2 import (\n    Command,\n    CommandType,\n    LuaExecutePayload,\n)\n\nresult = agent_client.send(\n    Command(\n        id=str(uuid4()),\n        operation_id=str(uuid4()),\n        type=CommandType.COMMAND_TYPE_LUA_EXECUTE,\n        lua_execute_payload=LuaExecutePayload(\n            executable_code='health = UnitHealth(\"player\")'\n        ),\n    )\n)\n</code></pre>"},{"location":"tutorials/communication/interact_with_agent/#2-lua-read-variable","title":"2. Lua Read Variable","text":"<p>Read the value of a Lua variable that was previously set:</p> <pre><code>from icecap.agent.v1.commands_pb2 import (\n    Command,\n    CommandType,\n    LuaReadVariablePayload,\n)\n\nresult = agent_client.send(\n    Command(\n        id=str(uuid4()),\n        operation_id=str(uuid4()),\n        type=CommandType.COMMAND_TYPE_LUA_READ_VARIABLE,\n        lua_read_variable_payload=LuaReadVariablePayload(\n            variable_name='health'\n        ),\n    )\n)\n\n# Access the result\nif result.type == EventType.EVENT_TYPE_LUA_VARIABLE_READ:\n    health_value = result.lua_variable_read_event_payload.result\n    print(f\"Player health: {health_value}\")\n</code></pre>"},{"location":"tutorials/communication/interact_with_agent/#3-click-to-move","title":"3. Click-to-Move","text":"<p>Control character movement using the game's click-to-move system:</p> <pre><code>from icecap.agent.v1.commands_pb2 import (\n    Command,\n    CommandType,\n    ClickToMovePayload,\n    ClickToMoveAction,\n)\nfrom icecap.agent.v1.common_pb2 import Position\n\nresult = agent_client.send(\n    Command(\n        id=str(uuid4()),\n        operation_id=str(uuid4()),\n        type=CommandType.COMMAND_TYPE_CLICK_TO_MOVE,\n        click_to_move_payload=ClickToMovePayload(\n            action=ClickToMoveAction.CLICK_TO_MOVE_ACTION_MOVE,\n            precision=0.5,  # Movement precision in yards\n            player_base_address=0x12345678,  # Base address of player object\n            position=Position(x=100.0, y=200.0, z=50.0),\n        ),\n    )\n)\n</code></pre>"},{"location":"tutorials/communication/interact_with_agent/#click-to-move-actions","title":"Click-to-Move Actions","text":"<ul> <li><code>CLICK_TO_MOVE_ACTION_FACE_TARGET</code>: Face a target entity</li> <li><code>CLICK_TO_MOVE_ACTION_FACE</code>: Face a specific direction</li> <li><code>CLICK_TO_MOVE_ACTION_MOVE</code>: Move to a position</li> </ul>"},{"location":"tutorials/communication/interact_with_agent/#understanding-events","title":"Understanding Events","text":"<p>Every command sent to the agent produces an event response. Events are defined in <code>icecap.agent.v1.events_pb2</code>:</p>"},{"location":"tutorials/communication/interact_with_agent/#event-types","title":"Event Types","text":"<ul> <li><code>EVENT_TYPE_LUA_VARIABLE_READ</code>: Response to a Lua variable read command</li> <li><code>EVENT_TYPE_OPERATION_SUCCEEDED</code>: Command completed successfully</li> <li><code>EVENT_TYPE_OPERATION_FAILED</code>: Command failed</li> </ul>"},{"location":"tutorials/communication/interact_with_agent/#processing-event-responses","title":"Processing Event Responses","text":"<p>The <code>send()</code> method returns an <code>Event</code> object that corresponds to your command:</p> <pre><code>from icecap.agent.v1.events_pb2 import EventType\n\nresult = agent_client.send(command)\n\nif result.type == EventType.EVENT_TYPE_OPERATION_SUCCEEDED:\n    print(\"Command succeeded!\")\nelif result.type == EventType.EVENT_TYPE_OPERATION_FAILED:\n    print(\"Command failed!\")\nelif result.type == EventType.EVENT_TYPE_LUA_VARIABLE_READ:\n    value = result.lua_variable_read_event_payload.result\n    print(f\"Variable value: {value}\")\n</code></pre>"},{"location":"tutorials/communication/interact_with_agent/#event-handlers","title":"Event Handlers","text":"<p>For asynchronous event processing, you can register event handlers that are called for all received events:</p> <pre><code>from icecap.agent.v1.events_pb2 import Event, EventType\n\ndef my_event_handler(event: Event) -&gt; None:\n    \"\"\"Handle incoming events from the agent.\"\"\"\n    print(f\"Received event: {event.id}, type: {event.type}\")\n\n    if event.type == EventType.EVENT_TYPE_LUA_VARIABLE_READ:\n        print(f\"Variable value: {event.lua_variable_read_event_payload.result}\")\n\n# Register the handler\nagent_client.add_event_handler(my_event_handler)\n\n# Your handler will be called for all events\n# ...\n\n# Remove the handler when done\nagent_client.remove_event_handler(my_event_handler)\n</code></pre>"},{"location":"tutorials/communication/interact_with_agent/#complete-example-reading-player-health","title":"Complete Example: Reading Player Health","text":"<p>Here's a complete example that reads the player's current health:</p> <pre><code>from uuid import uuid4\nfrom icecap.infrastructure.communication.rpc.factory import get_agent_client\nfrom icecap.agent.v1.commands_pb2 import (\n    Command,\n    CommandType,\n    LuaExecutePayload,\n    LuaReadVariablePayload,\n)\nfrom icecap.agent.v1.events_pb2 import EventType\n\n# Create and connect to the agent\nagent_client = get_agent_client()\nagent_client.connect()\n\ntry:\n    # Step 1: Execute Lua to store health in a variable\n    agent_client.send(\n        Command(\n            id=str(uuid4()),\n            operation_id=str(uuid4()),\n            type=CommandType.COMMAND_TYPE_LUA_EXECUTE,\n            lua_execute_payload=LuaExecutePayload(\n                executable_code='health = UnitHealth(\"player\")'\n            ),\n        )\n    )\n\n    # Step 2: Read the variable\n    result = agent_client.send(\n        Command(\n            id=str(uuid4()),\n            operation_id=str(uuid4()),\n            type=CommandType.COMMAND_TYPE_LUA_READ_VARIABLE,\n            lua_read_variable_payload=LuaReadVariablePayload(\n                variable_name='health'\n            ),\n        )\n    )\n\n    # Step 3: Process the result\n    if result.type == EventType.EVENT_TYPE_LUA_VARIABLE_READ:\n        health = result.lua_variable_read_event_payload.result\n        print(f\"Player health: {health}\")\n    else:\n        print(\"Failed to read health variable\")\n\nfinally:\n    # Always close the connection\n    agent_client.close()\n</code></pre>"},{"location":"tutorials/communication/interact_with_agent/#error-handling","title":"Error Handling","text":"<p>The agent client can raise several exceptions:</p> <pre><code>from icecap.infrastructure.communication.rpc.tcp.exceptions import (\n    AgentConnectionError,\n    AgentTimeoutError,\n)\n\ntry:\n    agent_client.connect(timeout=10.0)\n    result = agent_client.send(command, timeout=5.0)\nexcept AgentConnectionError as e:\n    print(f\"Connection error: {e}\")\nexcept AgentTimeoutError as e:\n    print(f\"Command timed out: {e}\")\n</code></pre>"},{"location":"tutorials/communication/interact_with_agent/#common-issues","title":"Common Issues","text":"<ol> <li>Connection refused: Ensure the agent DLL is injected and the TCP server is running</li> <li>Timeout errors: Increase the timeout value or check if the game is responding</li> <li>Invalid commands: Verify your Protocol Buffer messages are properly constructed</li> </ol>"},{"location":"tutorials/communication/interact_with_agent/#best-practices","title":"Best Practices","text":"<ol> <li>Use UUIDs for IDs: Always generate unique IDs for <code>id</code> and <code>operation_id</code> fields</li> <li>Handle timeouts: Set appropriate timeout values based on command complexity</li> <li>Close connections: Always close the client when done to free resources</li> <li>Check event types: Always verify the event type before accessing payload fields</li> <li>Error handling: Wrap send operations in try-except blocks</li> <li>Two-step pattern: Use the execute-then-read pattern for Lua operations that return values</li> </ol>"},{"location":"tutorials/communication/interact_with_agent/#advanced-usage","title":"Advanced Usage","text":""},{"location":"tutorials/communication/interact_with_agent/#custom-timeout-values","title":"Custom Timeout Values","text":"<pre><code># Custom connection timeout\nagent_client.connect(timeout=10.0)\n\n# Custom send timeout (wait indefinitely)\nresult = agent_client.send(command, timeout=None)\n</code></pre>"},{"location":"tutorials/communication/interact_with_agent/#multiple-event-handlers","title":"Multiple Event Handlers","text":"<p>You can register multiple event handlers for different purposes:</p> <pre><code>def logging_handler(event: Event) -&gt; None:\n    print(f\"[LOG] {event.id}: {event.type}\")\n\ndef metrics_handler(event: Event) -&gt; None:\n    # Record metrics\n    pass\n\nagent_client.add_event_handler(logging_handler)\nagent_client.add_event_handler(metrics_handler)\n</code></pre>"},{"location":"tutorials/communication/interact_with_agent/#reference","title":"Reference","text":"<ul> <li>Agent Repository: github.com/mora9715/icecap-agent</li> <li>Commands and Events definitions: github.com/mora9715/icecap-contracts/tree/main/icecap/agent/v1</li> </ul>"},{"location":"tutorials/navigation/work_with_minimap/","title":"Working with Minimap in Icecap","text":"<p>This guide will help you understand how to work with the Minimap service in Icecap, which allows you to render World of Warcraft minimaps based on game data.</p>"},{"location":"tutorials/navigation/work_with_minimap/#what-is-the-minimap-service","title":"What is the Minimap Service?","text":"<p>The Minimap service in Icecap provides functionality to access and render World of Warcraft minimaps. It allows you to:</p> <ul> <li>Load minimap textures from MPQ archives</li> <li>Render minimaps for specific map IDs</li> <li>Center the minimap on specific coordinates</li> <li>Adjust the zoom level and view extent</li> </ul>"},{"location":"tutorials/navigation/work_with_minimap/#basic-usage","title":"Basic Usage","text":""},{"location":"tutorials/navigation/work_with_minimap/#setting-up-the-minimap-service","title":"Setting Up the Minimap Service","text":"<p>To use the Minimap service, you first need to set up an MPQ archive chain and initialize the service:</p> <pre><code>from icecap.infrastructure.resource import MPQArchiveChain\nfrom icecap.services.navigation.minimap.service import MinimapService\n\n# Load the WoW data archives\nchain = MPQArchiveChain.load_archives(\"path/to/your/wow/Data\")\n\n# Initialize the minimap service\nminimap_service = MinimapService(chain)\n</code></pre>"},{"location":"tutorials/navigation/work_with_minimap/#getting-the-minimap","title":"Getting the Minimap","text":"<p>Once you have initialized the service, you can get the minimap data:</p> <pre><code># Get the minimap data\nminimap = minimap_service.get_minimap()\n</code></pre>"},{"location":"tutorials/navigation/work_with_minimap/#rendering-a-minimap","title":"Rendering a Minimap","text":"<p>To render a minimap for a specific location, you need: 1. A map ID 2. A position (coordinates) 3. An optional extent in pixels (for zoom level)</p> <pre><code>from icecap.domain.dto import Position\n\n# Define a position (x, y, z coordinates)\nposition = Position(x=1000, y=2000, z=100)\n\n# Define the map ID (e.g., 0 for Eastern Kingdoms, 1 for Kalimdor)\nmap_id = 1\n\n# Render the minimap with a 64-pixel extent (zoom level)\nminimap_image = minimap.render(map_id, position, extent_pixels=64)\n\n# If you're in a Jupyter notebook, you can display the image\nfrom IPython.display import display\ndisplay(minimap_image)\n\n# Or save the image to a file\nminimap_image.save(\"my_minimap.png\")\n</code></pre>"},{"location":"tutorials/navigation/work_with_minimap/#advanced-usage","title":"Advanced Usage","text":""},{"location":"tutorials/navigation/work_with_minimap/#working-with-map-positions","title":"Working with Map Positions","text":"<p>The <code>MapPosition</code> class is used to represent tile coordinates in the minimap system:</p> <pre><code>from icecap.services.navigation.minimap.dto import MapPosition\nfrom icecap.domain.dto import Position\n\n# Create a map position directly\nmap_pos = MapPosition(x=32, y=32)\n\n# Or convert from an entity position\nentity_pos = Position(x=1000, y=2000, z=100)\nmap_pos = MapPosition.from_entity_position(entity_pos)\n\nprint(f\"Map tile coordinates: ({map_pos.x}, {map_pos.y})\")\n</code></pre>"},{"location":"tutorials/navigation/work_with_minimap/#accessing-map-tiles","title":"Accessing Map Tiles","text":"<p>You can access individual map tiles if needed:</p> <pre><code># Get a specific map\nmap_obj = minimap.maps.get(map_id)\nif map_obj:\n    # Get a specific tile\n    tile = map_obj.tiles.get(MapPosition(x=32, y=32))\n    if tile:\n        # Access the tile's image\n        tile_image = tile.image\n        display(tile_image)\n</code></pre>"},{"location":"tutorials/navigation/work_with_minimap/#adjusting-the-render-extent","title":"Adjusting the Render Extent","text":"<p>The <code>extent_pixels</code> parameter controls how much of the map is shown:</p> <pre><code># Render just a single tile\nsingle_tile = minimap.render(map_id, position, extent_pixels=0)\n\n# Render a small area (128x128 pixels)\nsmall_area = minimap.render(map_id, position, extent_pixels=64)\n\n# Render a larger area (512x512 pixels)\nlarge_area = minimap.render(map_id, position, extent_pixels=256)\n</code></pre> <ul> <li> extent_pixels=64</li> <li> extent_pixels=128</li> <li> extent_pixels=256</li> </ul>"},{"location":"tutorials/navigation/work_with_minimap/#complete-example","title":"Complete Example","text":"<p>Here's a complete example that demonstrates how to use the Minimap service with a player's position from the game:</p> <pre><code>from icecap.infrastructure.resource import MPQArchiveChain\nfrom icecap.services.navigation.minimap.service import MinimapService\nfrom icecap.infrastructure import GameDriver, PlayerRepository\nfrom icecap.infrastructure.process import get_game_process_manager\nfrom icecap.infrastructure import get_memory_manager\nfrom IPython.display import display\n\n# Set up the MPQ archive chain\nchain = MPQArchiveChain.load_archives(\"path/to/your/wow/Data\")\n\n# Initialize the minimap service\nminimap_service = MinimapService(chain)\n\n# Set up the game driver and player repository to get the player's position\ndriver = GameDriver(get_game_process_manager(), get_memory_manager)\nplayer_repository = PlayerRepository(driver)\n\n# Get the player's position\nplayer = player_repository.get_local_player()\nposition = player.position\n\n# Get the current map ID\ncurrent_map_id = driver.object_manager.get_map_id()\n\n# Get the minimap data\nminimap = minimap_service.get_minimap()\n\n# Render the minimap centered on the player's position\n# with a 128x128 pixel view (64 pixels in each direction)\nminimap_image = minimap.render(current_map_id, position, extent_pixels=64)\n\n# Display the image\ndisplay(minimap_image)\n\n# Save the image to a file\nminimap_image.save(\"player_location_minimap.png\")\n\nprint(f\"Player position: {position}\")\nprint(f\"Current map ID: {current_map_id}\")\n</code></pre>"},{"location":"tutorials/navigation/work_with_minimap/#understanding-the-minimap-coordinate-system","title":"Understanding the Minimap Coordinate System","text":"<p>World of Warcraft uses a specific coordinate system for its world and minimap:</p> <ol> <li> <p>World Coordinates: The game world uses a coordinate system where (0,0) is at the center of the map, with values ranging from -MAX_MAP_COORDINATE to +MAX_MAP_COORDINATE.</p> </li> <li> <p>Minimap Tiles: The minimap is divided into tiles, each representing a portion of the game world. These tiles are indexed by x and y coordinates.</p> </li> <li> <p>Conversion: The <code>MapPosition.from_entity_position()</code> method converts from world coordinates to minimap tile coordinates.</p> </li> </ol> <pre><code># The conversion formula (simplified):\nx_tile = (MAX_MAP_COORDINATE - position.x) / WORLD_TILE_SIZE\ny_tile = (MAX_MAP_COORDINATE - position.y) / WORLD_TILE_SIZE\n</code></pre>"},{"location":"tutorials/navigation/work_with_minimap/#next-steps","title":"Next Steps","text":"<p>Now that you understand how to work with the Minimap service, you can:</p> <ul> <li>Create tools to visualize player movement on the map</li> <li>Build navigation systems using the minimap data</li> <li>Analyze map data for research purposes</li> <li>Create custom map visualizations</li> </ul> <p>For more information about working with game resources, check out the tutorials on Working with MPQ Archives and Working with DBC Files.</p>"}]}